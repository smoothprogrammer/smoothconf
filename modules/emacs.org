#+title: Emacs Configurations
#+property: header-args:elisp :mkdirp yes :results silent :tangle ~/.emacs.d/init.el
#+property: header-args:nix :results silent :tangle ./emacs.nix

* TODO LSP

- [X] eglot-booster → performance boost
- [ ] flymake (builtin) → diagnostics (already works with Eglot)
- [ ] consult-flymake → better diagnostics browsing
- [ ] tempel or yasnippet → snippets
- [ ] marginalia → annotations in minibuffer
- [ ] embark → context-sensitive actions
- [ ] corfu → completion frontend (already compatible)
- [ ] orderless → fuzzy matching in Corfu/Consult

* The config

I'm still new to emacs, try reading this in the future:

- https://taingram.org/blog/intro-to-emacs-tempo.html

Noweb reference:
- epkgs :: emacs packages
- pkgs :: nix packages
- config :: nix configuration

#+begin_src nix :noweb yes
  {
    config,
    lib,
    pkgs,
    ...
  }:

  with lib;

  let
    minimalEmacs = pkgs.emacs.overrideAttrs (oldAttrs: {
      preBuild = (oldAttrs.preBuild or "") + ''
        rm -rf lisp/play
        rm -rf lisp/obsolete
        rm -f lisp/isearchb.el
      '';
    });

    emacs = minimalEmacs.pkgs.withPackages (epkgs: [
      <<epkgs>>
  	]);

    cfg = config.mod.emacs;
  in

    {
  	options.mod.emacs = {
        enable = mkEnableOption "emacs";
  	};

  	config = mkIf cfg.enable {
        environment.systemPackages = [
  		emacs
        <<pkgs>>
        ];

      <<config>>

      mod.activationScripts.tangleEmacsConfig.text = ''
        ${emacs}/bin/emacs ${./.}/emacs.org \
          -Q --batch --eval '(org-babel-tangle nil nil "^elisp$")' --kill
      '';
  	};
    }
#+end_src

** Startup performance and default
:properties:
:header-args:elisp: :mkdirp yes :result silent :tangle ~/.emacs.d/early-init.el
:end:

Startup performance matters, I've seen a friend of mine opening Emacs and fully
load after 40 seconds. So keep the startup time low.

Emacs is featureful but has some bad default. Without 3rd party packages, we
will try to make QoL better.

*** Measure startup time and gc counts

This will give us base information wether our configuration is optimized or not.
If possible keep the startup time low.

#+begin_src elisp
  (add-hook 'emacs-startup-hook
            (lambda ()
              (message "Emacs loaded in %s with %d garbage collections."
                       (format "%.2f seconds"
                               (float-time
                                (time-subtract after-init-time before-init-time)))
                       gcs-done)))
#+end_src

*** GC

Temporary increase gc threshold during startup.

#+begin_src elisp
  (setq gc-cons-threshold most-positive-fixnum
        gc-cons-percentage 0.5)

  (add-hook 'emacs-startup-hook
            (lambda ()
              (setq gc-cons-threshold (* 8 100 100)
                    gc-cons-percentage 0.1)))
#+end_src

*** UI

Maximize the frame.

#+begin_src elisp
  (add-to-list 'initial-frame-alist '(fullscreen . maximized))
  (add-to-list 'default-frame-alist '(fullscreen . maximized))
#+end_src

Removing some UI elements. Most of them are ugly. Prefer minimal look.

#+begin_src elisp
  (unless (memq window-system '(mac ns))
    (menu-bar-mode -1))
  (tool-bar-mode -1)
  (scroll-bar-mode -1)
  (horizontal-scroll-bar-mode -1)
  (tooltip-mode -1)
#+end_src

*** QoL

Less noise, more peace.

#+begin_src elisp
  (setopt inhibit-startup-screen t
          inhibit-startup-buffer-menu t
          initial-scratch-message nil
          ring-bell-function 'ignore
          use-short-answers t)
#+end_src

Disable backup and lockfiles.

#+begin_src elisp
  (setopt make-backup-files nil
          create-lockfiles nil)
#+end_src

Still experiment for a better mapping in =macOS=.

#+begin_src elisp :tangle no
  (setopt mac-command-modifier 'control
          mac-right-command-modifier 'meta
          mac-option-modifier 'super)
#+end_src

Better main buffer default.

#+begin_src elisp
  (setopt sentence-end-double-space nil
          kill-whole-line t)
#+end_src

** Key binding

#+begin_src elisp :tangle no :noweb-ref normal-mode
  ("<escape>" keyboard-quit)
  ("i" ignore :exit t)
  ("I" beginning-of-line :exit t)
  ("a" forward-char :exit t)
  ("A" end-of-line :exit t)
  ("o" smooth/open-line-below :exit t)
  ("O" smooth/open-line-above :exit t)
#+end_src

#+begin_src elisp :tangle no :noweb-ref insert-mode
  ("<escape>" . ryo-modal-mode)
#+end_src

*** ryo

#+begin_src nix :tangle no :noweb-ref epkgs
  epkgs.ryo-modal
#+end_src

#+begin_src elisp :noweb yes
  <<ryo-helper>>

  (use-package ryo-modal
    :bind
    <<insert-mode>>
    :config
    (define-globalized-minor-mode global-ryo-modal-mode
      ryo-modal-mode
      (lambda ()
        (unless (smooth/modal-blacklisted-p)
          (ryo-modal-mode 1))))
    (global-ryo-modal-mode 1)
    (ryo-modal-keys
     <<normal-mode>>
     ))
#+end_src

#+begin_src elisp :tangle no :noweb-ref ryo-helper
  (defvar smooth/modal-blacklist
    '((predicate . minibufferp)
      (mode . eshell-mode)
      (mode . term-mode)
      (mode . vterm-mode)
      (mode . vc-git-log-edit-mode))
    "Alist of conditions where `ryo-modal-mode` should not be enabled.")

  (defun smooth/modal-blacklisted-p ()
    "Return non-nil if current buffer should not enable `ryo-modal-mode`."
    (cl-some
     (lambda (entry)
       (pcase entry
         (`(predicate . ,fn) (funcall fn))
         (`(mode . ,mode) (eq major-mode mode))))
     smooth/modal-blacklist))

  (defun smooth/open-line-below ()
    (interactive)
    (end-of-line)
    (open-line 1)
    (forward-line 1))

  (defun smooth/open-line-above ()
    (interactive)
    (beginning-of-line)
    (open-line 1))
#+end_src

** Directory and file :SPC:d:f:j:

#+begin_src elisp :tangle no :noweb-ref directory
  ("SPC d" project-dired :name "dired")
  ("SPC f" project-find-file :name "find file")
#+end_src

#+begin_src elisp :tangle no :noweb-ref special-file
  ("SPC j"
   (("e" smooth/open-emacs-config :name "open emacs config")
    ("w" smooth/open-work-readme :name "open work README"))
   :name "jump to special file")
#+end_src

*** dired

#+begin_src elisp :noweb yes
  <<dired-helper>>

  (use-package dired
    :ryo
    <<directory>>
    <<special-file>>
    )
#+end_src

#+begin_src elisp :tangle no :noweb-ref dired-helper
  (defun smooth/open-emacs-config ()
    (interactive)
    (find-file "~/.config/smoothconf/modules/emacs.org"))

  (defun smooth/open-work-readme ()
    (interactive)
    (find-file "~/work/README.org"))
#+end_src

** Movement and selection :v:

#+begin_src elisp :tangle no :noweb-ref movement
  ("h" backward-char)
  ("j" next-line)
  ("k" previous-line)
  ("l" forward-char)
  ("H" beginning-of-line)
  ("J" end-of-buffer)
  ("K" beginning-of-buffer)
  ("L" end-of-line)
#+end_src

#+begin_src elisp :tangle no :noweb-ref smooth-jump
  (";" avy-goto-char-timer)
#+end_src

#+begin_src elisp :tangle no :noweb-ref selection
  ("v" set-mark-command)
#+end_src

*** simple

#+begin_src elisp :noweb yes
  (use-package simple
    :ryo
    <<movement>>
    <<selection>>
    )
#+end_src

*** avy

#+begin_src nix :tangle no :noweb-ref epkgs
  epkgs.avy
#+end_src

#+begin_src elisp :noweb yes
  (use-package avy
    :ryo
    <<smooth-jump>>
    :custom
    (defun avy-action-helpful (pt)
      (save-excursion
        (goto-char pt)
        (helpful-at-point))
      (select-window
       (cdr ( avy-ring 0)))
      t)
    (setf (alist-get ?H avy-dispatch-alist) 'avy-action-helpful)
    (avy-timeout-seconds 0.3))
#+end_src

** Environment and Nix

Makes Emacs aware of the environment, especially within [[https://nixos.org/][Nix]] ecosystems. This is
something you want to be setup early on.

*** System path =exec-path-from-shell=

Read the system path from shell.

#+begin_src nix :tangle no :noweb-ref epkgs
  epkgs.exec-path-from-shell
#+end_src

#+begin_src elisp
  (use-package exec-path-from-shell
    :config
    (when (or (memq window-system '(mac ns x)) (daemonp))
      (dolist (var '("PATH"
                     "NIX_PATH"
                     "NIX_PROFILES"
                     "NIX_SSL_CERT_FILE"
                     "NIX_USER_PROFILE_DIR"
                     "__ETC_PROFILE_NIX_SOURCED"
                     "__NIX_DARWIN_SET_ENVIRONMENT_DONE"
                     "DIRENV_CONFIG"))
        (add-to-list 'exec-path-from-shell-variables var))
      (exec-path-from-shell-initialize)))
#+end_src

*** Direnv =envrc=

#+begin_src nix :tangle no :noweb-ref config
  programs.direnv = {
    enable = true;
    nix-direnv.enable = true;
  };
#+end_src

#+begin_src nix :tangle no :noweb-ref epkgs
  epkgs.envrc
#+end_src

#+begin_src elisp
  (use-package envrc
    :init (setopt envrc-debug t)
    :hook (after-init . envrc-global-mode))
#+end_src

** Help system :SPC:h:

#+begin_src elisp :tangle no :noweb-ref help
  ("SPC h"
   (("m" describe-mode :name "describe mode")
    ("h" helpful-at-point :name "describe at point")
    ("v" helpful-variable :name "describe variable")
    ("f" helpful-callable :name "describe function")
    ("k" helpful-key :name "describe key")
    ("x" helpful-command :name "describe command")
    ("j" pp-macroexpand-last-sexp))
   :name "help")
#+end_src

*** helpful

#+begin_src nix :tangle no :noweb-ref epkgs
  epkgs.helpful
#+end_src

#+begin_src elisp :noweb yes
  (use-package helpful
    :ryo
    <<help>>
    )
#+end_src

*** which-key

#+begin_src nix :tangle no :noweb-ref epkgs
  epkgs.which-key
#+end_src

#+begin_src elisp
  (use-package which-key
    :hook (after-init . which-key-mode))
#+end_src

*** keycast

#+begin_src nix :tangle no :noweb-ref epkgs
  epkgs.keycast
#+end_src

*** Markdown =markdown-mode=

#+begin_src nix :tangle no :noweb-ref epkgs
  epkgs.markdown-mode
#+end_src

#+begin_src elisp
  (use-package markdown-mode
    :mode (rx ".md" eos))
#+end_src

** UI

Who doesn't want a better UI?

*** Fonts and icons =nerd-icons=

Nerd Fonts all the way.

#+begin_src nix :tangle no :noweb-ref config
  fonts.packages = [ pkgs.nerd-fonts.iosevka ];
#+end_src

#+begin_src nix :tangle no :noweb-ref epkgs
  epkgs.nerd-icons
#+end_src

#+begin_src elisp
  (use-package nerd-icons
    :config (setopt nerd-icons-font-family "Iosevka Nerd Font"))
#+end_src

*** Themes =doom-themes=

Not a fan of dark themes, but light themes also too bright. Solarized with warm
and low contrast is a sweet spot for me.

#+begin_src nix :tangle no :noweb-ref epkgs
  epkgs.doom-themes
#+end_src

#+begin_src elisp
  (use-package doom-themes
    :config
    (load-theme 'doom-solarized-light t)
    (doom-themes-org-config))
#+end_src

*** Mode line =doom-modeline=

Doom modeline to complement the themes.

#+begin_src nix :tangle no :noweb-ref epkgs
  epkgs.doom-modeline
#+end_src

#+begin_src elisp
  (use-package doom-modeline
   :init (doom-modeline-mode)
   :custom
   (doom-modeline-project-name t))
#+end_src

*** QoL

Give Emacs some space to breath.

#+begin_src nix :tangle no :noweb-ref epkgs
  epkgs.spacious-padding
#+end_src

#+begin_src elisp
  (use-package spacious-padding
    :config
    (setq spacious-padding-widths
  		'( :internal-border-width 15
  		   :header-line-width 4
  		   :mode-line-width 6
  		   :tab-width 4
  		   :right-divider-width 30
  		   :scroll-bar-width 8
  		   :fringe-width 4))
    (spacious-padding-mode 1))
#+end_src

*** Annotation =marginalia=

#+begin_src nix :tangle no :noweb-ref epkgs
  epkgs.marginalia
    epkgs.nerd-icons-completion
#+end_src

#+begin_src elisp
  (use-package marginalia
    :init (marginalia-mode))
  (use-package nerd-icons-completion
    :after marginalia
    :config
    (nerd-icons-completion-mode)
    (add-hook 'marginalia-mode-hook #'nerd-icons-completion-marginalia-setup))
#+end_src

** Completion

Completion are essential feature for modern text editor / IDE.

#+begin_src elisp
  (setq read-file-name-completion-ignore-case t
        read-buffer-completion-ignore-case t
        completion-ignore-case t)
#+end_src

** Smooth default =built-in=

Emacs are featureful out of the box, but has a bad default configuration. This
is an attempt to make a smooth default without 3rd party packages.

*** Zooming

Smooth zooming with =0 - += and its shift counter part key.

#+begin_src elisp
  (define-key global-map (kbd "C-0") (lambda () (interactive) (text-scale-set 0)))
  (define-key global-map (kbd "C-)") (lambda () (interactive) (text-scale-set 0)))
  (define-key global-map (kbd "C--") 'text-scale-decrease)
  (define-key global-map (kbd "C-_") 'text-scale-decrease)
  (define-key global-map (kbd "C-=") 'text-scale-increase)
  (define-key global-map (kbd "C-+") 'text-scale-increase)
#+end_src

*** Files, buffers, and minibuffer

EditorConfig cover some file formatting in an editor-agnostic way.

#+begin_src elisp
  (editorconfig-mode t)
#+end_src

Make the buffer and its corresponding file in sync.

#+begin_src elisp
  (global-auto-revert-mode t)
#+end_src

Replace active region when insert text.

#+begin_src elisp
  (delete-selection-mode t)
#+end_src

Make TAB do indent + complete.

#+begin_src elisp
  (setq-default tab-always-indent 'complete)
#+end_src

Set tab to 4. We will define a global variable ~global-tab-width~ since other
major mode might have their own setting for this, we can override them with this
variable.

#+begin_src elisp
  (defvar global-tab-width 4)
  (setq-default tab-width global-tab-width)
#+end_src

Limit the column to 80 character.

#+begin_src elisp
  (setq-default fill-column 80)
  (add-hook 'text-mode-hook 'auto-fill-mode)
#+end_src

Treat subword movement for camel case in programming mode.

#+begin_src elisp
  (add-hook 'prog-mode-hook 'subword-mode)
#+end_src

Make script with shebang in it executable.

#+begin_src elisp
  (add-hook 'after-save-hook 'executable-make-buffer-file-executable-if-script-p)
#+end_src

** LSP :g:

#+begin_src elisp :tangle no :noweb-ref xref
  ("g d" xref-find-definitions :name "go to definitions")
  ("g r" xref-find-references :name "go to references")
  ("g ," xref-go-back :name "go back")
  ("g ." xref-go-forward :name "go forward")
#+end_src

#+begin_src elisp :tangle no :noweb-ref consult
  ("g i" consult-imenu :name "go to imenu")
  ("g f" consult-flymake :name "go to flymake")
#+end_src

*** eglot

We will use built-in =eglot= for LSP. Make sure the LSP server is installed in the system
path and configure the following variable:

+ eglot-server-programs :: mapping between major mode and the LSP server
+ eglot-workspace-configuration :: configuration for the LSP server

#+begin_src elisp :noweb yes
  (use-package eglot
    :hook
    (prog-mode . eglot-ensure)
    (prog-mode . (lambda () (add-hook 'before-save-hook 'eglot-format-buffer)))
    :config
    (setq eglot-server-programs '(
                                  <<eglot-server-programs>>
                                  ))
    (setq-default eglot-workspace-configuration
                  '(
                    <<eglot-workspace-configuration>>
                    )))
#+end_src

*** eglot-booster

Boost LSP performance with =eglot-booster=.

#+begin_src nix :tangle no :noweb-ref epkgs
  epkgs.eglot-booster
#+end_src

#+begin_src elisp
  (use-package eglot-booster :after eglot :config (eglot-booster-mode))
#+end_src

*** eldoc-box

#+begin_src nix :tangle no :noweb-ref epkgs
  epkgs.eldoc-box
#+end_src

#+begin_src elisp
  (use-package eldoc-box
    :hook (eglot-managed-mode . eldoc-box-hover-mode))
#+end_src

*** xref

#+begin_src elisp :noweb yes
  (use-package xref
    :ryo
    <<xref>>
    )
#+end_src

*** corfu :ui:

#+begin_src nix :tangle no :noweb-ref epkgs
  epkgs.corfu
#+end_src

#+begin_src elisp
  (use-package corfu
    :hook
    (after-init . global-corfu-mode)
    (after-init . corfu-popupinfo-mode)
    :custom
    (corfu-cycle t)
    (corfu-auto t)
    (corfu-auto-delay 0.0)
    (corfu-auto-prefix 2)
    (corfu-popupinfo-delay 0.3)
    (corfu-popupinfo-hide nil)
    :config
    (keymap-unset corfu-map "RET")
    :bind
    (:map corfu-map
  		("C-j" . corfu-next)
  		("C-k" . corfu-previous)))
#+end_src

*** cape

#+begin_src nix :tangle no :noweb-ref epkgs
  epkgs.cape
#+end_src

#+begin_src elisp
  (use-package cape
    :config
    (add-hook 'completion-at-point-functions #'cape-file))
#+end_src

*** vertico :ui:

#+begin_src nix :tangle no :noweb-ref epkgs
  epkgs.vertico
#+end_src

#+begin_src elisp
  (use-package vertico
    :hook
    (after-init . vertico-mode)
    :custom
    (vertico-cycle t)
    :bind
    (:map vertico-map
  		("C-j" . vertico-next)
  		("C-k" . vertico-previous)
          ("RET" . vertico-directory-enter)
          ("DEL" . vertico-directory-delete-char)
          ("M-DEL" . vertico-directory-delete-word)))
#+end_src

*** corderless

#+begin_src nix :tangle no :noweb-ref epkgs
  epkgs.orderless
#+end_src

#+begin_src elisp
  (use-package orderless
    :config
    (setq completion-styles '(orderless basic)
          completion-category-default nil
          completion-category-overrides '((file (styles partial-completion)))
          orderless-matching-styles '(orderless-flex)))
#+end_src

*** consult

#+begin_src nix :tangle no :noweb-ref epkgs
  epkgs.consult
#+end_src

#+begin_src elisp :noweb yes
  (use-package consult
    :ryo
    <<consult>>
    :custom
    (xref-show-xrefs-function #'consult-xref)
    (xref-show-definitions-function #'consult-xref))
#+end_src

** TODO Programming language

Syntax highlighting require [[https://tree-sitter.github.io/tree-sitter/][Tree-sitter]] grammars, this will install all
available grammars.

#+begin_src nix :tangle no :noweb-ref epkgs
  epkgs.treesit-grammars.with-all-grammars
#+end_src

*** go :main:

#+begin_src nix :tangle no :noweb-ref pkgs
  pkgs.go
    pkgs.gopls
    pkgs.delve
#+end_src

#+begin_src nix :tangle no :noweb-ref epkgs
  # go-ts-mode is already emacs built-in major mode
#+end_src

#+begin_src elisp
  (use-package go-ts-mode
    :mode (rx ".go" eos)
    :custom (go-ts-mode-indent-offset global-tab-width))
#+end_src

#+begin_src elisp :tangle no :noweb-ref eglot-server-programs
  ((go-mode go-dot-mod-mode go-dot-work-mode go-ts-mode go-mod-ts-mode) . ("gopls"))
#+end_src

#+begin_src elisp :tangle no :noweb-ref eglot-workspace-configuration
  (:gopls . (:gofumpt t))
#+end_src

*** gleam :main:

#+begin_src nix :tangle no :noweb-ref pkgs
  pkgs.gleam
#+end_src

#+begin_src nix :tangle no :noweb-ref epkgs
  epkgs.gleam-ts-mode
#+end_src

#+begin_src elisp
  (use-package gleam-ts-mode
    :mode (rx ".gleam" eos))
#+end_src

#+begin_src elisp :tangle no :noweb-ref eglot-server-programs
  (gleam-ts-mode . ("gleam" "lsp"))
#+end_src

*** elisp :conf:

Emacs at the heart is a Lisp interpreter, so everything already available out of
the box.

*** nix :conf:

#+begin_src nix :tangle no :noweb-ref epkgs
  epkgs.nix-ts-mode
#+end_src

#+begin_src elisp
  (use-package nix-ts-mode
    :mode (rx ".nix" eos))
#+end_src

#+begin_src elisp :tangle no :noweb-ref eglot-server-programs
  (nix-ts-mode . ("nil"))
#+end_src

#+begin_src elisp :tangle no :noweb-ref eglot-workspace-configuration
  (:nil . (:formatting (:command ["nixfmt"])))
#+end_src

Fontify Org mode noweb reference for Nix.

#+begin_src elisp
  (defun smooth/nix-ts-mode-noweb-comment ()
    "Treat `<<...>>` as comment in nix-mode to avoid indentation errors."
    (font-lock-add-keywords
     nil '(("<<.*?>>" . font-lock-comment-face))))

  (add-hook 'nix-ts-mode-hook #'smooth/nix-ts-mode-noweb-comment)
#+end_src

*** js/json

#+begin_src elisp
  (use-package js
    :mode ((rx ".js" eos)
           (rx ".json" eos))
    :custom (js-indent-level 2))
#+end_src

** Org

#+begin_src elisp :tangle no :noweb-ref org
  ("SPC SPC c" org-ctrl-c-ctrl-c)
  ;; insert structure template
  ;; see: org-structure-template-alist
#+end_src

#+begin_src elisp :tangle no :noweb-ref org-insert
  ("SPC i"
   (("t" org-insert-structure-template :name "insert template")
    ("h" org-babel-insert-header-arg :name "insert header")
    ("l" org-insert-link :name "insert link"))
   :name "org insert")
#+end_src

#+begin_src elisp :tangle no :noweb-ref babel
  ("SPC SPC t" org-babel-tangle)
#+end_src

*** org

#+begin_src elisp :noweb yes
  (use-package org
    :ryo
    (:mode 'org-mode)
    <<org>>
    <<org-insert>>
    <<babel>>
    :custom
    ;; Edit settings.
    (org-auto-align-tags nil)
    (org-tags-column 0)
    (org-catch-invisible-edits 'show-and-error)
    (org-special-ctrl-a/e t)
    (org-insert-heading-respect-content t)
    ;; Org styling, hide markup etc.
    (org-startup-indented t)
    (org-startup-folded 'content)
    (org-hide-emphasis-markers t)
    (org-pretty-entities t)
    (org-agenda-tags-column 0)
    (org-ellipsis "…")
    (org-cycle-separator-lines 0)
    (org-imenu-depth 3))
#+end_src

*** org-auto-tangle

Keep the tangled file in sync.

#+begin_src nix :tangle no :noweb-ref epkgs
  epkgs.org-auto-tangle
#+end_src

#+begin_src elisp
  (use-package org-auto-tangle
    :hook (org-mode . org-auto-tangle-mode)
    :custom (org-auto-tangle-default t))
#+end_src

*** org-modern

The default look is old with no icon, make the look modern.

#+begin_src nix :tangle no :noweb-ref epkgs
  epkgs.org-modern
#+end_src

#+begin_src elisp
  (use-package org-modern
    :hook (org-mode . org-modern-mode))
#+end_src

*** org-modern-indent

Package =org-modern-mode= is [[https://github.com/minad/org-modern?tab=readme-ov-file#incompatibilities][incompatible]] with built-in =org-indent-mode=, fix them with =org-modern-indent-mode=.

#+begin_src nix :tangle no :noweb-ref epkgs
  (pkgs.emacsPackages.trivialBuild {
    pname = "org-modern-indent";
    version = "0.5.1";
    src = pkgs.fetchFromGitHub {
      owner = "jdtsmith";
      repo = "org-modern-indent";
      rev = "v0.5.1";
      sha256 = "sha256-st3338Jk9kZ5BLEPRJZhjqdncMpLoWNwp60ZwKEObyU=";
    };
  })
#+end_src

#+begin_src elisp
  (use-package org-modern-indent
    :hook (org-mode . org-modern-indent-mode))
#+end_src

*** ob-babel

Register the programming languages to support in evaluation. See [[https://orgmode.org/worg/org-contrib/babel/languages/index.html][Babel language support]].

#+begin_src elisp
  (org-babel-do-load-languages
   'org-babel-load-languages
   '((emacs-lisp . t)
     (verb . t)))
  (setq org-confirm-babel-evaluate nil)
#+end_src

Register missing major mode for some programing languages.

+ C-h v org-src-lang-modes RET :: see registered major mode (some already registered by default)

#+begin_src elisp
  (add-to-list 'org-src-lang-modes '("nix" . nix-ts))
  (add-to-list 'org-src-lang-modes '("js" . js))
  (add-to-list 'org-src-lang-modes '("json" . js))
#+end_src

*** ox-hugo

#+begin_src nix :tangle no :noweb-ref epkgs
  epkgs.ox-hugo
#+end_src

#+begin_src elisp
  (use-package ox-hugo
    :after ox)
#+end_src

*** TODO org-present

#+begin_src nix :tangle no :noweb-ref epkgs
  epkgs.org-present
#+end_src

*** TODO org-roam

#+begin_src nix :tangle no :noweb-ref epkgs
  epkgs.org-roam
    epkgs.org-roam-ui
#+end_src

*** verb

#+begin_src nix :tangle no :noweb-ref epkgs
  epkgs.verb
#+end_src

#+begin_src elisp
  (use-package verb
    :hook
    ((org-mode . smooth/org-enable-verb-mode-if-has-tag)
     (org-after-tags-change-hook . smooth/org-enable-verb-mode-if-has-tag))
    :config
    (defun smooth/org-enable-verb-mode-if-has-tag ()
      "Toggle `verb-mode` based on Org buffer has the tag :verb:."
      (interactive)
      (if (member '("verb") (org-get-buffer-tags))
          (verb-mode 1)
        (verb-mode -1))))
#+end_src

*** hurl

#+begin_src nix :tangle no :noweb-ref pkgs
  pkgs.hurl
#+end_src

#+begin_src nix :tangle no :noweb-ref epkgs
  (pkgs.emacsPackages.trivialBuild {
    pname = "hurl-mode";
    version = "0.0.0";
    src = pkgs.fetchFromGitHub {
      owner = "JasZhe";
      repo = "hurl-mode";
      rev = "0753271bb4693924d3dcfa9d66a316086d7b7b72";
      sha256 = "sha256-56/XDXYG4pq3+liB9TDIISTlmN4xMGsic9jhrIacO5E=";
    };
  })
#+end_src

#+begin_src elisp
  (use-package hurl-mode
    :mode (rx ".hurl" eos))
#+end_src

** Version control :SPC:v:g:

#+begin_src elisp :tangle no :noweb-ref vc
  ("SPC v"
   (("v" vc-next-action :name "next action")
    ("s" project-vc-dir :name "status")
    ("h" vc-annotate :name "annotate")
    ("d" vc-diff :name "diff")
    ("l" vc-print-log :name "log")
    ("p" vc-push :name "push"))
   :name "version control")
#+end_src

#+begin_src elisp :tangle no :noweb-ref git
  ("SPC g"
   (("s" magit-status :name "status"))
   :name "git")
#+end_src

#+begin_src elisp :tangle no :noweb-ref blamer
  ("SPC v b" blamer-show-posframe-commit-info :name "blame")
#+end_src

*** vc

#+begin_src elisp :noweb yes
  (use-package vc
    :ryo
    <<vc>>
    :custom
    (vc-follow-symlink t)
    (vc-handled-backends '(Git)))
#+end_src

*** magit

#+begin_src nix :tangle no :noweb-ref epkgs
  epkgs.magit
#+end_src

#+begin_src elisp :noweb yes
  (use-package magit
    :ryo
    <<git>>
    )
#+end_src

*** diff-hl

#+begin_src nix :tangle no :noweb-ref epkgs
  epkgs.diff-hl
#+end_src

#+begin_src elisp
  (use-package diff-hl
    :hook (after-init . global-diff-hl-mode)
    :config (setq diff-hl-bmp-max-width 8))
#+end_src

*** blamer

#+begin_src nix :tangle no :noweb-ref epkgs
  epkgs.blamer
#+end_src

#+begin_src elisp :noweb yes
  (use-package blamer
    :ryo
    <<blamer>>
    )
#+end_src

** Accounting

*** ledger-mode

#+begin_src nix :tangle no :noweb-ref pkgs
  pkgs.ledger
#+end_src

#+begin_src nix :tangle no :noweb-ref epkgs
  epkgs.ledger-mode
#+end_src

#+begin_src elisp
  (use-package ledger-mode)
#+end_src
