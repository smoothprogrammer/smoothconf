#+title: Emacs Configurations
#+property: header-args:elisp :mkdirp yes :results silent :tangle ~/.emacs.d/init.el
#+property: header-args:nix :results silent :tangle ./emacs.nix
#+auto-tangle: t
#+auto-reload: ~/.emacs.d/init.el

* TODO Future

+ consider using punch-line
+ more tempel template (also move to its own section)
+ sql, nosql, redis client
+ consider using mwim
+ consider using literate-calc-mode
+ consider using smart-hungry-delete
+ consider using expand-region
+ consider using multi-compile
+ consider using prodigy and cask
+ consider using go-playground
+ consider using kubernetes-el
+ add folding
+ add debugger, dap-mode?
+ ai?

* Emacs Nix module

I'm still new to emacs, try reading this in the future:

- https://taingram.org/blog/intro-to-emacs-tempo.html

Noweb reference:
- epkgs :: emacs packages
- pkgs :: nix packages
- config :: nix configuration

#+begin_src nix
  {
    config,
    lib,
    pkgs,
    ...
  }:

  with lib;

  let
    minimalEmacs = pkgs.emacs.overrideAttrs (oldAttrs: {
      preBuild = (oldAttrs.preBuild or "") + ''
        rm -rf lisp/play
        rm -rf lisp/obsolete
        rm -f lisp/isearchb.el
      '';
    });

    emacs = minimalEmacs.pkgs.withPackages (epkgs: [
      <<epkgs>>
      ]);

    cfg = config.mod.emacs;
  in

    {
      options.mod.emacs = {
        enable = mkEnableOption "emacs";
      };

      config = mkIf cfg.enable {
        environment.systemPackages = [
          emacs
        <<pkgs>>
        ];

      <<config>>

      mod.activationScripts.tangleEmacsConfig.text = ''
        ${emacs}/bin/emacs ${./.}/emacs.org \
          -Q --batch --eval '(org-babel-tangle nil nil "^elisp$")' --kill
      '';
      };
    }
#+end_src

* Startup performance
:properties:
:header-args:elisp: :mkdirp yes :result silent :tangle ~/.emacs.d/early-init.el
:end:

Startup performance matters, I've seen a friend of mine opening Emacs and fully
load after 40 seconds. So keep the startup time low.

This will give us base information when startup wether our configuration is
optimized or not.

#+begin_src elisp
  (add-hook 'emacs-startup-hook
            (lambda ()
              (message "Emacs loaded in %s with %d garbage collections."
                       (format "%.2f seconds" (float-time (time-subtract after-init-time before-init-time)))
                       gcs-done)))
#+end_src

Temporary increase gc threshold during startup.

#+begin_src elisp
  (setq gc-cons-threshold most-positive-fixnum
        gc-cons-percentage 0.5)

  (add-hook 'emacs-startup-hook
            (lambda ()
              (setq gc-cons-threshold (* 8 100 100)
                    gc-cons-percentage 0.1)))
#+end_src

Maximize the frame.

#+begin_src elisp
  (add-to-list 'initial-frame-alist '(fullscreen . maximized))
  (add-to-list 'default-frame-alist '(fullscreen . maximized))
#+end_src

Removing some UI elements. Most of them are ugly. Prefer minimal look.

#+begin_src elisp
  (unless (memq window-system '(mac ns))
    (menu-bar-mode -1))
  (tool-bar-mode -1)
  (scroll-bar-mode -1)
  (horizontal-scroll-bar-mode -1)
  (tooltip-mode -1)
  (setq tab-bar-show nil)
#+end_src

Less noise, more peace.

#+begin_src elisp
  (setopt inhibit-startup-screen t
          inhibit-startup-buffer-menu t
          initial-scratch-message nil
          ring-bell-function 'ignore
          use-short-answers t)
#+end_src

Lastly, defer loading a package using =use-package=.

#+begin_src elisp
  (setq use-package-always-defer t)
#+end_src

* Better default

Emacs are featureful out of the box, but has a bad default configuration. This
is an attempt to make a smooth default without 3rd party packages.

Enable lexical binding.

#+begin_src elisp
  ;; -*- lexical-binding: t; -*-
#+end_src

Smooth zooming with =0 - += and its shift counter part key.

#+begin_src elisp
  (define-key global-map (kbd "C-0") (lambda () (interactive) (text-scale-set 0)))
  (define-key global-map (kbd "C-)") (lambda () (interactive) (text-scale-set 0)))
  (define-key global-map (kbd "C--") 'text-scale-decrease)
  (define-key global-map (kbd "C-_") 'text-scale-decrease)
  (define-key global-map (kbd "C-=") 'text-scale-increase)
  (define-key global-map (kbd "C-+") 'text-scale-increase)
#+end_src

EditorConfig cover some file formatting in an editor-agnostic way.

#+begin_src elisp
  (editorconfig-mode t)
#+end_src

Make the buffer and its corresponding file in sync.

#+begin_src elisp
  (global-auto-revert-mode t)
#+end_src

Replace active region when insert text.

#+begin_src elisp
  (delete-selection-mode t)
#+end_src

Make TAB do indent + complete.

#+begin_src elisp
  (setq-default tab-always-indent 'complete)
#+end_src

Set tab to 4. We will define a global variable ~global-tab-width~ since other
major mode might have their own setting for this, we can override them with this
variable.

#+begin_src elisp
  (defvar global-tab-width 4)
  (setq-default tab-width global-tab-width)
#+end_src

Limit the column to 80 character.

#+begin_src elisp
  (setq-default fill-column 80)
  (add-hook 'text-mode-hook 'auto-fill-mode)
#+end_src

Treat subword movement for camel case in programming mode.

#+begin_src elisp
  (add-hook 'prog-mode-hook 'subword-mode)
#+end_src

Make script with shebang in it executable.

#+begin_src elisp
  (add-hook 'after-save-hook 'executable-make-buffer-file-executable-if-script-p)
#+end_src

Disable backup and lockfiles.

#+begin_src elisp
  (setopt make-backup-files nil
          create-lockfiles nil)
#+end_src

Better main buffer default.

#+begin_src elisp
  (setopt sentence-end-double-space nil)
#+end_src

* Environment and Nix

Makes Emacs aware of the environment, especially within [[https://nixos.org/][Nix]] ecosystems. This is
something you want to be setup early on.

** exec-path-from-shell

Read the system path from shell.

#+begin_src nix :tangle no :noweb-ref epkgs
  epkgs.exec-path-from-shell
#+end_src

#+begin_src elisp
  (use-package exec-path-from-shell
    :demand t
    :custom
    (exec-path-from-shell-warn-duration-millis 500)
    :config
    (when (or (memq window-system '(mac ns x)) (daemonp))
      (dolist (var '("PATH"
                     "NIX_PATH"
                     "NIX_PROFILES"
                     "NIX_SSL_CERT_FILE"
                     "NIX_USER_PROFILE_DIR"
                     "__ETC_PROFILE_NIX_SOURCED"
                     "__NIX_DARWIN_SET_ENVIRONMENT_DONE"
                     "DIRENV_CONFIG"))
        (add-to-list 'exec-path-from-shell-variables var))
      (exec-path-from-shell-initialize)))
#+end_src

** envrc

#+begin_src nix :tangle no :noweb-ref config
  programs.direnv = {
    enable = true;
    nix-direnv.enable = true;
  };
#+end_src

#+begin_src nix :tangle no :noweb-ref epkgs
  epkgs.envrc
#+end_src

#+begin_src elisp
  (use-package envrc
    :hook (after-init . envrc-global-mode)
    :custom
    (envrc-debug t))
#+end_src

* TODO Smooth modal

Coming from Vim, modal editing is a must. In Emacs, we have options like [[https://github.com/emacs-evil/evil][evil]],
[[https://github.com/jyp/boon][boon]], and [[https://github.com/meow-edit/meow][meow]]. But I really like [[https://github.com/Kungsgeten/ryo-modal][ryo-modal]] where I can customize modal editing
to my own liking.

We'll use meow and evil as a learning source and reference.

#+begin_src nix :tangle no :noweb-ref epkgs
  epkgs.meow
  epkgs.evil
#+end_src

#+begin_src elisp
  (use-package meow)
  (use-package evil)
src

** smooth

#+begin_src elisp
  (defvar smooth--state nil)

  (defvar smooth-normal-map (make-sparse-keymap))
  (defvar smooth-insert-map (make-sparse-keymap))
  (defvar smooth-mode-normal-maps nil
    "List of (MODE . MAP) pairs for normal state.")
  (defvar smooth-mode-insert-maps nil
    "List of (MODE . MAP) pairs for insert state.")

  (defun smooth--mode-p (mode)
    (cond
     ((eq mode major-mode) t)
     ((derived-mode-p mode) t)
     ((and (boundp mode) (symbol-value mode)) t)
     (t nil)))

  (defun smooth--refresh-keymap ()
    (setq minor-mode-overriding-map-alist
  		(assq-delete-all 'smooth-mode minor-mode-overriding-map-alist))
    (cond
     ((eq smooth--state 'normal)
  	(let ((pair (seq-find (lambda (pair)
  							(smooth--mode-p (car pair)))
  						  smooth-mode-normal-maps)))
  	  (push `(smooth-mode . ,smooth-normal-map) minor-mode-overriding-map-alist)
  	  (when pair
  		(push `(smooth-mode . ,(cdr pair)) minor-mode-overriding-map-alist))))
     ((eq smooth--state 'insert)
  	(let ((pair (seq-find (lambda (pair)
  							(smooth--mode-p (car pair)))
  						  smooth-mode-insert-maps)))
  	  (push `(smooth-mode . ,smooth-insert-map) minor-mode-overriding-map-alist)
  	  (when pair
  		(push `(smooth-mode . ,(cdr pair)) minor-mode-overriding-map-alist))))))

  (defun smooth-enter-normal-state ()
    (interactive)
    (setq-local smooth--state 'normal)
    (setq-local cursor-type 'bar)
    (focus-mode 0)
    (smooth--refresh-keymap))

  (defun smooth-enter-insert-state ()
    (interactive)
    (setq-local smooth--state 'insert)
    (setq-local cursor-type 'bar)
    (focus-mode 1)
    (smooth--refresh-keymap))

  (defun smooth-reset-state ()
    (kill-local-variable 'smooth--state)
    (kill-local-variable 'cursor-type)
    (smooth--refresh-keymap))

  (defvar smooth--hist-backward-stack nil)
  (defvar smooth--hist-forward-stack nil)

  (defun smooth--hist-make-entry ()
    (let* ((win (selected-window))
  		 (buf (window-buffer win))
  		 (pos (window-point win)))
      (list :window win :buffer buf :point pos)))

  (defun smooth--hist-jump-to (entry)
    (let ((win (plist-get entry :window))
  		(buf (plist-get entry :buffer))
  		(pos (plist-get entry :point)))
      (cond
       ((window-live-p win)
        (select-window win)
        (switch-to-buffer buf)
        (goto-char pos))
       (t
        (switch-to-buffer buf)
        (goto-char pos)))))

  (defun smooth--hist-record ()
    (interactive)
    (push (smooth--hist-make-entry) smooth--hist-backward-stack)
    (setq smooth--hist-forward-stack nil))

  (defun smooth--hist-backward ()
    (interactive)
    (if (null smooth--hist-backward-stack)
        (message "No older position")
      (push (smooth--hist-make-entry) smooth--hist-forward-stack)
      (smooth--hist-jump-to (pop smooth--hist-backward-stack))))

  (defun smooth--hist-forward ()
    (interactive)
    (if (null smooth--hist-forward-stack)
        (message "No newer position")
      (push (smooth--hist-make-entry) smooth--hist-backward-stack)
      (smooth--hist-jump-to (pop smooth--hist-forward-stack))))

  (defun smooth--open-line-below ()
    (interactive)
    (end-of-line)
    (newline)
    (indent-according-to-mode))

  (defun smooth--open-line-above ()
    (interactive)
    (beginning-of-line)
    (open-line 1)
    (indent-according-to-mode))

  (defun smooth--yank (count)
    (interactive "p")
    (if (use-region-p)
        (kill-ring-save (region-beginning) (region-end))
      (kill-new (char-to-string (char-after)))))

  (defun smooth--put (count)
    (interactive "p")
    (when (use-region-p)
      (delete-region (region-beginning) (region-end)))
    (yank))

  (defun smooth--kill (count)
    (interactive "p")
    (if (use-region-p)
        (kill-region (region-beginning) (region-end))
      (delete-char count t)))

  (defun smooth--escape ()
    (interactive)
    (cond
     ;; 1. Corfu popup is visible
     ((and (bound-and-true-p corfu-mode)
        	 corfu--candidates)
      (corfu-quit)
      (smooth-enter-normal-state))

     ;; 2. Minibuffer
     ((when (minibufferp)
        (minibuffer-keyboard-quit)))

     ;; 3. Enter ryo-modal-mode
     (t (smooth-enter-normal-state))))

  (defun smooth--pulse (pulse)
    (when (memq pulse '(red green blue))
      (let ((fn (intern (format "pulsar-pulse-line-%s" pulse))))
        (when (fboundp fn)
          (funcall fn)))))

  (defun smooth--resolve-select (select)
    (cl-case select
      (activate
       (push-mark (point) t t))
      (deactivate
       (deactivate-mark))
      (extend
       (unless (use-region-p) (push-mark (point) t t)))))

  (defmacro smooth-keys (&rest forms)
    (let ((state nil)
  		(mode nil)
  		(expansions nil))
      (dolist (form forms)
        (unless (consp form)
  		(error "smooth-keys: invalid form: %S" form))
        (let ((new-state (plist-get form :state))
  			(new-mode (plist-get form :mode)))
  		(cond
  		 ((or new-state new-mode)
  		  (when new-state (setq state new-state))
  		  (when new-mode (setq mode new-mode)))
  		 (t
  		  (unless state
  			(error "smooth-keys: key binding appears before setting state"))
  		  (let* ((key (nth 0 form))
  				 (cmd (nth 1 form))
  				 (args (cddr form))
  				 (name (plist-get args :name))
  				 (record (plist-get args :record))
  				 (select (plist-get args :select))
  				 (insert (plist-get args :insert))
  				 (pulse (plist-get args :pulse))
  				 (keymap (if mode
  							 `(cdr (assoc ',mode
  										  ,(if (eq state 'normal)
  											   'smooth-mode-normal-maps
  											 'smooth-mode-insert-maps)))
  						   (intern (format "smooth-%s-map" state)))))
  			(when mode
  			  (let ((table (if (eq state 'normal)
  							   'smooth-mode-normal-maps
  							 'smooth-mode-insert-maps)))
  				(unless (assoc mode (symbol-value table))
  				  (push (cons mode (make-sparse-keymap))
  						(symbol-value table)))))
  			(if (not name)
  				(push `(keymap-set ,keymap ,key #',cmd) expansions)
  			  (let ((sym (intern (format "smooth:%s" name))))
  				(push
  				 `(progn
  					(fset ',sym
  						  (lambda ()
  							(interactive)
  							,@(when (and pulse (eq cmd 'keyboard-quit))
  								`((smooth--pulse ',pulse)))
  							,@(when (and record (not insert))
  								`((smooth--hist-record)))
  							,@(when (and select (not insert))
  								`((smooth--resolve-select ',select)))
  							,@(unless (eq cmd 'ignore)
  								`((call-interactively #',cmd)))
  							,@(when insert
  								`((smooth--resolve-select 'deactivate)
  								  (smooth-enter-insert-state)))
  							,@(when (and pulse (not (eq cmd 'keyboard-quit)))
  								`((smooth--pulse ',pulse)))))
  					(keymap-set ,keymap ,key #',sym))
  				 expansions))))))))
  	`(progn ,@(nreverse expansions))))

  (with-eval-after-load 'use-package-core
    (unless (member :smooth use-package-keywords)
      (setq use-package-keywords (use-package-list-insert :smooth use-package-keywords :bind)))
    (when (boundp 'use-package-deferring-keywords)
      (add-to-list 'use-package-deferring-keywords :smooth t))
    (defun use-package-normalize/:smooth (name keyword args)
      args)
    (defun use-package-handler/:smooth (name keyword args rest state)
      (use-package-concat
       (use-package-process-keywords name rest state)
       `((smooth-keys ,@args)))))

  (define-minor-mode smooth-mode
    "Toggle Smooth modal editing (Smooth mode)."
    :keymap nil
    (if smooth-mode
  	  (if (and (minibufferp))
  		  (smooth-enter-insert-state)
  		(smooth-enter-normal-state))
      (smooth-reset-state)))

  (define-global-minor-mode global-smooth-mode smooth-mode
    (lambda ()
      (smooth-mode 1)))

  (smooth-keys
   <<smooth-default>>
   <<smooth-motion>>
   <<smooth-insert>>
   <<smooth-editing>>
   )

  (add-hook 'after-init-hook 'global-smooth-mode)
#+end_src

** smooth-default

#+begin_src elisp :tangle no :noweb-ref smooth-default
  (:state insert)
  ("<escape>" smooth--escape :name escape-insert :pulse green)
  ("ESC" smooth--escape :name escape-insert :pulse green)

  (:state normal)
  ("<escape>" smooth--escape :name escape-normal :select deactivate :pulse red)
  ("ESC" smooth--escape :name escape :select deactivate :pulse red)
  ("<delete>" undefined)
  ("DEL" undefined)
  ("<return>" undefined)
  ("RET" undefined)
  ;; ("<space>" undefined)
  ;; ("SPC" undefined)

  (:state normal)
  ("1" digit-argument)
  ("2" undefined)
  ("3" undefined)
  ("4" undefined)
  ("5" undefined)
  ("6" undefined)
  ("7" undefined)
  ("8" undefined)
  ("9" undefined)
  ("0" undefined)

  (:state normal)
  ("`" undefined)
  ("~" undefined)
  ("!" undefined)
  ("@" undefined)
  ("#" undefined)
  ("$" undefined)
  ("%" undefined)
  ("^" undefined)
  ("&" undefined)
  ("*" undefined)
  ("(" undefined)
  (")" undefined)
  ("-" undefined)
  ("_" undefined)
  ("=" undefined)
  ("+" undefined)
  ("[" undefined)
  ("{" undefined)
  ("]" undefined)
  ("}" undefined)
  ("\\" undefined)
  ("|" undefined)
  (";" undefined)
  (":" undefined)
  ("'" undefined)
  ("\"" undefined)
  ("," undefined)
  ("<" undefined)
  ("." undefined)
  (">" undefined)
  ("/" undefined)
  ("?" undefined)

  (:state normal)
  ("a" undefined)
  ("b" undefined)
  ("c" undefined)
  ("d" undefined)
  ;; ("e" undefined)
  ("f" undefined)
  ;; ("g" undefined)
  ("h" undefined)
  ("i" undefined)
  ("j" undefined)
  ("k" undefined)
  ("l" undefined)
  ("m" undefined)
  ("n" undefined)
  ("o" undefined)
  ("p" undefined)
  ("q" quit-window)
  ("r" undefined)
  ("s" undefined)
  ("t" undefined)
  ("u" undefined)
  ("v" undefined)
  ;; ("w" undefined)
  ("x" execute-extended-command)
  ("y" undefined)
  ("z" undefined)

  (:state normal)
  ("A" undefined)
  ("B" undefined)
  ("C" undefined)
  ("D" undefined)
  ("E" undefined)
  ("F" undefined)
  ;; ("G" undefined)
  ("H" undefined)
  ("I" undefined)
  ("J" undefined)
  ("K" undefined)
  ("L" undefined)
  ("M" undefined)
  ("N" undefined)
  ("O" undefined)
  ("P" undefined)
  ("Q" undefined)
  ("R" undefined)
  ("S" undefined)
  ("T" undefined)
  ("U" undefined)
  ("V" undefined)
  ("W" undefined)
  ("X" undefined)
  ("Y" undefined)
  ("Z" undefined)
#+end_src

** smooth-motion

#+begin_src elisp :tangle no :noweb-ref smooth-motion
  (:state normal)
  ("h" backward-char :name left :select deactivate)
  ("j" next-line :name down :select deactivate)
  ("k" previous-line :name up :select deactivate)
  ("l" forward-char :name right :select deactivate)
  ("b" backward-word :name word-left :select activate)
  ("f" forward-word :name word-right :select activate)
  ("g h" move-beginning-of-line :name line-begin :record t :select deactivate)
  ("g j" end-of-buffer :name buffer-end :record t :select deactivate)
  ("g k" beginning-of-buffer :name buffer-begin :record t :select deactivate)
  ("g l" move-end-of-line :name line-end :record t :select deactivate)

  ("H" backward-char :name extend-left :select extend)
  ("J" next-line :name extend-down :select extend)
  ("K" previous-line :name extend-up :select extend)
  ("L" forward-char :name extend-right :select extend)
  ("B" backward-word :name extend-word-left :select extend)
  ("F" forward-word :name extend-word-right :select extend)
  ("G H" move-beginning-of-line :name extend-line-begin :record t :select extend)
  ("G J" end-of-buffer :name extend-buffer-end :record t :select extend)
  ("G K" beginning-of-buffer :name extend-buffer-begin :record t :select extend)
  ("G L" move-end-of-line :name extend-line-end :record t :select extend)

  ("%" mark-whole-buffer :name whole-buffer :record t)
  ("," smooth--hist-backward :name back :select deactivate)
  ("." smooth--hist-forward :name forward :select deactivate)
#+end_src

** smooth-insert

#+begin_src elisp :tangle no :noweb-ref smooth-insert
  ("i" ignore :name insert :insert t :pulse blue)
  ("a" forward-char :name append :insert t :pulse blue)
  ("o" smooth--open-line-below :name open-line-below :insert t :pulse blue)
  ("c" smooth--kill :name change :insert t :pulse blue)

  ("I" move-beginning-of-line :name insert-begin :insert t :pulse blue)
  ("A" move-end-of-line :name append-end :insert t :pulse blue)
  ("O" smooth--open-line-above :name open-line-above :insert t :pulse blue)
  ("C" kill-line :name change-end :insert t :pulse blue)
#+end_src

** smooth-editing

#+begin_src elisp :tangle no :noweb-ref smooth-editing
  (:state normal)
  ("u" undo-only :name undo)
  ("U" undo-redo :name redo)
  ("y" smooth--yank :name yank)
  ("p" smooth--put :name put)
  ("d" smooth--kill :name delete)
  ("D" kill-line :name delete-line)
#+end_src

* UI

Who doesn't want a better UI?

** faces :font:

Nerd Fonts all the way.

#+begin_src nix :tangle no :noweb-ref config
  fonts.packages = with pkgs.nerd-fonts; [
    fira-code
    jetbrains-mono
    iosevka
  ];
#+end_src

#+begin_src elisp
  (use-package faces
    :demand t
    :config
    (set-face-attribute 'default nil :font "FiraCode Nerd Font"))
#+end_src

** nerd-icons :font:

Support Nerd Fonts for the icons.

#+begin_src nix :tangle no :noweb-ref epkgs
  epkgs.nerd-icons
#+end_src

#+begin_src elisp
  (use-package nerd-icons
    :demand t
    :custom
    (nerd-icons-font-family "FiraCode Nerd Font"))
#+end_src

** doom-themes :theme:

Not a fan of dark themes, but light themes also too bright. Solarized with warm
and low contrast is a sweet spot for me.

#+begin_src nix :tangle no :noweb-ref epkgs
  epkgs.doom-themes
#+end_src

#+begin_src elisp
  (use-package doom-themes
    :demand t
    :config
    (load-theme 'doom-solarized-light t)
    (doom-themes-org-config))
#+end_src

** doom-modeline :theme:

Doom modeline to complement the themes.

#+begin_src nix :tangle no :noweb-ref epkgs
  epkgs.doom-modeline
#+end_src

#+begin_src elisp
  (use-package doom-modeline
    :hook (after-init . doom-modeline-mode)
    :custom
    (doom-modeline-workspace-name nil))
#+end_src

** corfu :completion:

#+begin_src nix :tangle no :noweb-ref epkgs
  epkgs.corfu
#+end_src

#+begin_src elisp
  (use-package corfu
    :hook
    (after-init . global-corfu-mode)
    (after-init . corfu-popupinfo-mode)
    :bind
    (:map corfu-map
          ("C-j" . corfu-next)
          ("C-k" . corfu-previous))
    :custom
    (corfu-cycle t)
    (corfu-auto t)
    (corfu-auto-delay 0.0)
    (corfu-auto-prefix 2)
    (corfu-popupinfo-delay 0.0)
    (corfu-popupinfo-hide nil)
    :config
    (keymap-unset corfu-map "RET"))
#+end_src

** vertico :completion:

#+begin_src nix :tangle no :noweb-ref epkgs
  epkgs.vertico
#+end_src

#+begin_src elisp
  (use-package vertico
    :hook (after-init . vertico-mode)
    :bind
    (:map vertico-map
          ("C-j" . vertico-next)
          ("C-k" . vertico-previous)
          ("RET" . vertico-directory-enter)
          ("DEL" . vertico-directory-delete-char)
          ("M-DEL" . vertico-directory-delete-word))
    :custom
    (vertico-cycle t))
#+end_src

** marginalia :completion:

Add annotation to the minibuffer.

#+begin_src nix :tangle no :noweb-ref epkgs
  epkgs.marginalia
#+end_src

#+begin_src elisp
  (use-package marginalia
    :hook (after-init . marginalia-mode))
#+end_src

** nerd-icons-completion :completion:font:

Fix =nerd-icons= doesn't affect minibuffer.

#+begin_src nix :tangle no :noweb-ref epkgs
  epkgs.nerd-icons-completion
#+end_src

#+begin_src elisp
  (use-package nerd-icons-completion
    :after marginalia
    :hook
    (marginalia-mode . nerd-icons-completion-mode)
    (marginalia-mode . nerd-icons-completion-marginalia-setup))
#+end_src

** TODO focus :focus:

Focus around the point.

#+begin_src nix :tangle no :noweb-ref epkgs
  epkgs.focus
#+end_src

#+begin_src elisp
  (use-package focus)
#+end_src

** golden-ratio :focus:

Focus on the current window.

#+begin_src nix :tangle no :noweb-ref epkgs
  epkgs.golden-ratio
#+end_src

#+begin_src elisp
  (use-package golden-ratio
    :smooth
    (:state normal)
    ("+" golden-ratio))
#+end_src
** windmove :window:

Easier switching window.

#+begin_src elisp
  (use-package windmove
    :smooth
    (:state normal)
    ("w h" windmove-left)
    ("w j" windmove-down)
    ("w k" windmove-up)
    ("w l" windmove-right))
#+end_src
** spacious-padding

Give Emacs some space to breath.

#+begin_src nix :tangle no :noweb-ref epkgs
  epkgs.spacious-padding
#+end_src

#+begin_src elisp
  (use-package spacious-padding
    :hook (after-init . spacious-padding-mode)
    :custom
    (spacious-padding-widths
     '( :internal-border-width 15
        :header-line-width 4
        :mode-line-width 6
        :tab-width 4
        :right-divider-width 30
        :scroll-bar-width 8
        :fringe-width 4)))
#+end_src

** ansi-color

Fix text in compilation buffer.

#+begin_src elisp
  (use-package ansi-color
    :hook (compilation-filter . ansi-color-compilation-filter))
#+end_src

** pulsar

Visual indicator to help easily spot current line.

#+begin_src nix :tangle no :noweb-ref epkgs
  epkgs.pulsar
#+end_src

#+begin_src elisp
  (use-package pulsar
    :demand t)
#+end_src

* Help system

** helpful

#+begin_src nix :tangle no :noweb-ref epkgs
  epkgs.helpful
#+end_src

#+begin_src elisp
  (use-package helpful
    :smooth
    (:state normal)
    ("SPC h h" helpful-at-point :name describe-at-point)
    ("SPC h m" describe-mode :name describe-mode)
    ("SPC h v" helpful-variable :name describe-variable)
    ("SPC h f" helpful-callable :name describe-function)
    ("SPC h k" helpful-key :name describe-key)
    ("SPC h x" helpful-command :name describe-command)
    ("SPC h j" pp-macroexpand-last-sexp :name expand-macro))
#+end_src

** which-key

#+begin_src nix :tangle no :noweb-ref epkgs
  epkgs.which-key
#+end_src

#+begin_src elisp
  (use-package which-key
    :hook (after-init . which-key-mode))
#+end_src

** keycast

#+begin_src nix :tangle no :noweb-ref epkgs
  epkgs.keycast
#+end_src

** markdown-mode

#+begin_src nix :tangle no :noweb-ref epkgs
  epkgs.markdown-mode
#+end_src

#+begin_src elisp
  (use-package markdown-mode
    :mode (rx ".md" eos))
#+end_src

* Project

** project

#+begin_src elisp
  (use-package project
    :smooth
    (:state normal)
    ("SPC p" project-switch-project :name "project")
    ("SPC SPC d" project-dired :name "root directory")
    ("SPC d" dired-jump :name "directory")
    ("SPC SPC f" project-find-file :name "root file")
    ("SPC f" find-file :name "file")
    ("SPC c" project-compile  :name "compile")
    ("SPC e" project-eshell :name "eshell")
    ("SPC b" project-switch-to-buffer :name "buffer")
    :custom
    (project-switch-commands #'smooth/project-auto-buffer)
    :config
    (defun smooth/project-auto-buffer ()
      "After switching to a project, jump to its first buffer or *scratch*."
      (interactive)
      (let* ((pr (project-current))
             (buffers (project-buffers pr)))
        (if buffers
            (switch-to-buffer (car buffers))
          (project-find-file)))))
#+end_src

** otpp

#+begin_src nix :tangle no :noweb-ref epkgs
  epkgs.otpp
#+end_src

#+begin_src elisp
  (use-package otpp
    :smooth
    (:state normal)
    ("SPC j e" smooth/open-emacs-config :name open-emacs-config)
    ("SPC j w" smooth/open-work-readme :name open-work-readme)
    :hook
    (after-init . otpp-mode)
    (after-init . otpp-override-mode)
    :config
    (setq frame-title-format
          '(:eval
            (alist-get 'name (tab-bar--current-tab))))

    (defun smooth/open-emacs-config ()
      (interactive)
      (let ((buf (find-file "~/.config/smoothconf/modules/emacs.org")))
        (otpp-detach-buffer-to-tab buf)))

    (defun smooth/open-work-readme ()
      (interactive)
      (find-file "~/work/README.org")))
#+end_src

** harpoon

#+begin_src nix :tangle no :noweb-ref epkgs
  epkgs.harpoon
#+end_src

#+begin_src elisp
  (use-package harpoon
    :defer t
    :smooth
    (:state normal)
    ("SPC a" harpoon-add-file)
    ("SPC o" harpoon-toggle-file)
    ("SPC 1" harpoon-go-to-1)
    ("SPC 2" harpoon-go-to-2)
    ("SPC 3" harpoon-go-to-3)
    ("SPC 4" harpoon-go-to-4)
    ("SPC 4" harpoon-go-to-5))
#+end_src

* Completion

Completion are essential feature for modern text editor / IDE.

#+begin_src elisp
  (setq read-file-name-completion-ignore-case t
        read-buffer-completion-ignore-case t
        completion-ignore-case t)
#+end_src

** consult

#+begin_src nix :tangle no :noweb-ref epkgs
  epkgs.consult
#+end_src

#+begin_src elisp
  (use-package consult
    :smooth
    (:state normal)
    ("g m" consult-imenu :first '(smooth-deactivate-anchor))
    ("g e" consult-flymake :first '(smooth-deactivate-anchor))
    :custom
    (xref-show-xrefs-function #'consult-xref)
    (xref-show-definitions-function #'consult-xref))
#+end_src

** orderless

#+begin_src nix :tangle no :noweb-ref epkgs
  epkgs.orderless
#+end_src

#+begin_src elisp
  (use-package orderless
    :custom
    (completion-styles '(orderless basic))
    (completion-category-default nil)
    (completion-category-overrides '((file (styles partial-completion))))
    (orderless-matching-styles '(orderless-flex)))
#+end_src

** cape

#+begin_src nix :tangle no :noweb-ref epkgs
  epkgs.cape
#+end_src

#+begin_src elisp
  (use-package cape
    :demand t
    :config
    (add-hook 'completion-at-point-functions #'cape-file)
    (add-hook 'completion-at-point-functions #'cape-elisp-block))
#+end_src

** tempel

#+begin_src nix :tangle no :noweb-ref epkgs
  epkgs.tempel
  epkgs.eglot-tempel
#+end_src

#+begin_src elisp
  (use-package tempel)

  (use-package eglot-tempel
    :hook (after-init . eglot-tempel-mode))
#+end_src

* LSP

** eglot

We will use built-in =eglot= for LSP. Make sure the LSP server is installed in the
system path and configure the following variable:

+ eglot-server-programs :: mapping between major mode and the LSP server
+ eglot-workspace-configuration :: configuration for the LSP server

#+begin_src elisp
  (use-package eglot
    :smooth
    (:state normal)
    ("g i" eglot-find-implementation :select deactivate)
    ("r" eglot-rename :select deactivate)
    :hook
    (prog-mode . eglot-ensure)
    (prog-mode . (lambda () (add-hook 'before-save-hook 'eglot-format-buffer)))
    :custom
    (eglot-events-buffer-config '(:size 0))
    :config
    (setq eglot-server-programs '(
                                  <<eglot-server-programs>>
                                  ))
    (setq-default eglot-workspace-configuration
                  '(
                    <<eglot-workspace-configuration>>
                    )))
#+end_src

** eglot-booster

Boost LSP performance with =eglot-booster=.

#+begin_src nix :tangle no :noweb-ref pkgs
  pkgs.emacs-lsp-booster
#+end_src

#+begin_src nix :tangle no :noweb-ref epkgs
  epkgs.eglot-booster
#+end_src

#+begin_src elisp
  (use-package eglot-booster
    :after eglot
    :config
    (eglot-booster-mode))
#+end_src

** eldoc

#+begin_src elisp
  (use-package eldoc
    :custom
    (eldoc-idle-delay 0.0)
    (eldoc-echo-area-use-multiline-p 1)
    (eldoc-echo-area-display-truncation-message nil))
#+end_src

** eldoc-box

#+begin_src nix :tangle no :noweb-ref epkgs
  epkgs.eldoc-box
#+end_src

#+begin_src elisp
  (use-package eldoc-box
    :smooth
    (:state normal)
    ("?" eldoc-box-help-at-point))
#+end_src

** flymake

#+begin_src elisp
  (use-package flymake
    :smooth
    (:state normal)
    ("e j" flymake-goto-next-error :name "goto next error")
    ("e k" flymake-goto-prev-error :name "goto prev error"))
#+end_src

** xref

#+begin_src elisp
  (use-package xref
    :smooth
    (:state normal)
    ("g d" xref-find-definitions :first '(smooth-deactivate-anchor))
    ("g r" xref-find-references :first '(smooth-deactivate-anchor)))
#+end_src

* Programming language

Syntax highlighting require [[https://tree-sitter.github.io/tree-sitter/][Tree-sitter]] grammars, this will install all
available grammars.

#+begin_src nix :tangle no :noweb-ref epkgs
  epkgs.treesit-grammars.with-all-grammars
#+end_src

** go :main:

#+begin_src nix :tangle no :noweb-ref pkgs
  pkgs.go
  pkgs.gopls
  pkgs.delve
#+end_src

#+begin_src nix :tangle no :noweb-ref epkgs
  # go-ts-mode is already emacs built-in major mode
#+end_src

#+begin_src elisp
  (use-package go-ts-mode
    :mode (rx ".go" eos)
    :custom
    (go-ts-mode-indent-offset global-tab-width))
#+end_src

#+begin_src elisp :tangle no :noweb-ref eglot-server-programs
  ((go-mode go-dot-mod-mode go-dot-work-mode go-ts-mode go-mod-ts-mode) . ("gopls"))
#+end_src

#+begin_src elisp :tangle no :noweb-ref eglot-workspace-configuration
  (:gopls . (:gofumpt t))
#+end_src

** gleam :main:

#+begin_src nix :tangle no :noweb-ref pkgs
  pkgs.gleam
#+end_src

#+begin_src nix :tangle no :noweb-ref epkgs
  epkgs.gleam-ts-mode
#+end_src

#+begin_src elisp
  (use-package gleam-ts-mode
    :mode (rx ".gleam" eos))
#+end_src

#+begin_src elisp :tangle no :noweb-ref eglot-server-programs
  (gleam-ts-mode . ("gleam" "lsp"))
#+end_src

** erlang

#+begin_src nix :tangle no :noweb-ref pkgs
  pkgs.beam28Packages.erlang
  pkgs.erlang-language-platform
#+end_src

#+begin_src elisp :tangle no :noweb-ref epkgs
  epkgs.erlang-ts
#+end_src

#+begin_src elisp
  (use-package erlang-ts-mode
    :mode (rx ".erl" eos))
#+end_src

#+begin_src elisp :tangle no :noweb-ref eglot-server-programs
  (erlang-ts-mode . ("elp" "server"))
#+end_src

** elisp :conf:

Emacs at the heart is a Lisp interpreter, so everything already available out of
the box.

** nix :conf:

#+begin_src nix :tangle no :noweb-ref pkgs
  pkgs.nil
  pkgs.nixfmt
#+end_src

#+begin_src nix :tangle no :noweb-ref epkgs
  epkgs.nix-ts-mode
#+end_src

#+begin_src elisp
  (use-package nix-ts-mode
    :mode (rx ".nix" eos)
    :hook (nix-ts-mode . smooth/nix-ts-mode-noweb-comment)
    :config
    (defun smooth/nix-ts-mode-noweb-comment ()
      "Treat `<<...>>` as comment in nix-mode to avoid indentation errors."
      (font-lock-add-keywords
       nil '(("<<.*?>>" . font-lock-comment-face)))))
#+end_src

#+begin_src elisp :tangle no :noweb-ref eglot-server-programs
  (nix-ts-mode . ("nil"))
#+end_src

#+begin_src elisp :tangle no :noweb-ref eglot-workspace-configuration
  (:nil . (:formatting (:command ["nixfmt"])))
#+end_src

** js/json

#+begin_src elisp
  (use-package js
    :mode
    (rx ".js" eos)
    (rx ".json" eos)
    :custom
    (js-indent-level 2))
#+end_src

** guile :noob:

#+begin_src nix :tangle no :noweb-ref pkgs
  pkgs.guile
#+end_src

#+begin_src nix :tangle no :noweb-ref epkgs
  epkgs.geiser
  epkgs.geiser-guile
#+end_src

#+begin_src elisp
  (use-package geiser)
  (use-package geiser-guile)
#+end_src

** lua :noob:

#+begin_src nix :tangle no :noweb-ref pkgs
  pkgs.luajit
  pkgs.lua-language-server
#+end_src

#+begin_src nix :tangle no :noweb-ref epkgs
  # lua-ts-mode is already emacs built-in major mode
#+end_src

#+begin_src elisp
  (use-package lua-ts-mode
    :mode (rx ".lua" eos))
#+end_src

#+begin_src elisp :tangle no :noweb-ref eglot-server-programs
  ((lua-ts-mode) . ("lua-language-server"))
#+end_src

* TODO Org

** org

#+begin_src elisp
  (use-package org
    :smooth
    (:state normal :mode org-mode)
    ("SPC i t" org-insert-structure-template)
    ("SPC i h" org-babel-insert-header-arg)
    ("SPC i l" org-insert-link)
    :hook (after-save . org-auto--tangle-and-reload)
    :custom
    ;; Edit settings.
    (org-auto-align-tags nil)
    (org-tags-column 0)
    (org-catch-invisible-edits 'show-and-error)
    (org-special-ctrl-a/e t)
    (org-insert-heading-respect-content t)
    ;; Org styling, hide markup etc.
    (org-startup-indented t)
    (org-startup-folded 'content)
    (org-hide-emphasis-markers t)
    (org-pretty-entities t)
    (org-agenda-tags-column 0)
    (org-ellipsis "â€¦")
    (org-cycle-separator-lines 0)
    (org-imenu-depth 3)
    :config
    (defun org-auto--find-keywords-value (key)
  	(car (cdr (assoc (upcase key) (org-collect-keywords (list key))))))

    (defun org-auto--tangle-and-reload ()
      (when (derived-mode-p 'org-mode)
        (let ((auto-tangle (org-auto--find-keywords-value "auto-tangle"))
              (auto-reload (org-auto--find-keywords-value "auto-reload"))
  			(ops '()))
          (when (string= auto-tangle "t")
            (org-babel-tangle)
  		  (push "tangled" ops))
          (when auto-reload
            (load-file auto-reload)
  		  (push "reloaded" ops))
  		(when ops
  		  (message "Auto: %s" (string-join (nreverse ops) " and ")))))))
#+end_src

** org-modern

The default look is old with no icon, make the look modern.

#+begin_src nix :tangle no :noweb-ref epkgs
  epkgs.org-modern
#+end_src

#+begin_src elisp
  (use-package org-modern
    :hook (org-mode . org-modern-mode))
#+end_src

** org-modern-indent

The =org-modern-mode= is [[https://github.com/minad/org-modern?tab=readme-ov-file#incompatibilities][incompatible]] with built-in =org-indent-mode=, fix them
with =org-modern-indent-mode=.

#+begin_src nix :tangle no :noweb-ref epkgs
  (pkgs.emacsPackages.trivialBuild {
    pname = "org-modern-indent";
    version = "0.5.1";
    src = pkgs.fetchFromGitHub {
      owner = "jdtsmith";
      repo = "org-modern-indent";
      rev = "v0.5.1";
      sha256 = "sha256-st3338Jk9kZ5BLEPRJZhjqdncMpLoWNwp60ZwKEObyU=";
    };
  })
#+end_src

#+begin_src elisp
  (use-package org-modern-indent
    :hook (org-mode . org-modern-indent-mode))
#+end_src

** TODO ob-babel

Register the programming languages to support in evaluation. See [[https://orgmode.org/worg/org-contrib/babel/languages/index.html][Babel language
support]].

#+begin_src elisp
  (org-babel-do-load-languages
   'org-babel-load-languages
   '((emacs-lisp . t)
     (verb . t)))
  (setq org-confirm-babel-evaluate nil)
  (setf (alist-get :noweb org-babel-default-header-args) "yes")
#+end_src

Register missing major mode for some programing languages.

+ C-h v org-src-lang-modes RET :: see registered major mode (some already registered by default)

#+begin_src elisp
  (add-to-list 'org-src-lang-modes '("nix" . nix-ts))
  (add-to-list 'org-src-lang-modes '("js" . js))
  (add-to-list 'org-src-lang-modes '("json" . js))
#+end_src

** TODO ox-hugo

#+begin_src nix :tangle no :noweb-ref epkgs
  epkgs.ox-hugo
#+end_src

#+begin_src elisp
  (use-package ox-hugo
    :after ox)
#+end_src

** TODO org-present

#+begin_src nix :tangle no :noweb-ref epkgs
  epkgs.org-present
#+end_src

** TODO org-roam

#+begin_src nix :tangle no :noweb-ref epkgs
  epkgs.org-roam
  epkgs.org-roam-ui
#+end_src

** verb

#+begin_src nix :tangle no :noweb-ref epkgs
  epkgs.verb
#+end_src

#+begin_src elisp
  (use-package verb
    :hook
    ((org-mode . smooth/org-enable-verb-mode-if-has-tag)
     (org-after-tags-change-hook . smooth/org-enable-verb-mode-if-has-tag))
    :config
    (defun smooth/org-enable-verb-mode-if-has-tag ()
      "Toggle `verb-mode` based on Org buffer has the tag :verb:."
      (interactive)
      (if (member '("verb") (org-get-buffer-tags))
          (verb-mode 1)
        (verb-mode -1))))
#+end_src

** hurl

#+begin_src nix :tangle no :noweb-ref pkgs
  pkgs.hurl
#+end_src

#+begin_src nix :tangle no :noweb-ref epkgs
  (pkgs.emacsPackages.trivialBuild {
    pname = "hurl-mode";
    version = "0.0.0";
    src = pkgs.fetchFromGitHub {
      owner = "JasZhe";
      repo = "hurl-mode";
      rev = "0753271bb4693924d3dcfa9d66a316086d7b7b72";
      sha256 = "sha256-56/XDXYG4pq3+liB9TDIISTlmN4xMGsic9jhrIacO5E=";
    };
  })
#+end_src

#+begin_src elisp
  (use-package hurl-mode
    :mode (rx ".hurl" eos))
#+end_src

* TODO Version control

** magit

#+begin_src nix :tangle no :noweb-ref epkgs
  epkgs.magit
#+end_src

#+begin_src elisp
  (use-package magit
    :smooth
    (:state normal)
    ("SPC g s" magit-status)
    (:mode magit-mode)
    ("j" magit-section-forward)
    ("k" magit-section-backward)
    ("TAB" magit-section-toggle)
    ("q" magit-mode-bury-buffer)
    ("d" magit-diff-dwim)
    ("a" magit-apply)
    ("x" magit-discard)
    ("s" magit-stage)
    ("u" magit-unstage)
    ("c c" magit-commit-create)
    ("c a" magit-commit-amend)
    ("p u" magit-push-current-to-upstream)
    :custom
    (auto-revert-check-vc-info t))
#+end_src

** blamer

#+begin_src nix :tangle no :noweb-ref epkgs
  epkgs.blamer
#+end_src

#+begin_src elisp
  (use-package blamer
    :smooth
    (:state normal)
    ("SPC g b" blamer-show-posframe-commit-info))
#+end_src

** diff-hl

#+begin_src nix :tangle no :noweb-ref epkgs
  epkgs.diff-hl
#+end_src

#+begin_src elisp
  (use-package diff-hl
    :hook
    (after-init . global-diff-hl-mode)
    (magit-post-refresh . diff-hl-magit-post-refresh)
    :custom
    (diff-hl-bmp-max-width 8))
#+end_src

* Others

** avy

[[https://karthinks.com/software/avy-can-do-anything/][Avy can do anything]]. However, most of the time, I only use =avy= for jump only.

#+begin_src nix :tangle no :noweb-ref epkgs
  epkgs.avy
#+end_src

#+begin_src elisp
  (use-package avy
    :smooth
    (:state normal)
    (";" avy-goto-char-2 :name avy :pulse green)
    (":" avy-goto-char-2 :name extend-avy :select extend :pulse green)
    :custom
    (avy-single-candidate-jump nil)
    (avy-style 'words)
    (avy-dispatch-alist nil))
#+end_src

** jwt

#+begin_src nix :tangle no :noweb-ref epkgs
  epkgs.jwt
#+end_src

#+begin_src elisp
  (use-package jwt)
#+end_src

** TODO ledger-mode

#+begin_src nix :tangle no :noweb-ref pkgs
  pkgs.ledger
#+end_src

#+begin_src nix :tangle no :noweb-ref epkgs
  epkgs.ledger-mode
#+end_src

#+begin_src elisp
  (use-package ledger-mode)
#+end_src
