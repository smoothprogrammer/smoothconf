#+title: Emacs Configurations
#+property: header-args:elisp :mkdirp yes :results silent :tangle ~/.emacs.d/init.el
#+property: header-args:nix :results silent :tangle ./emacs.nix
#+auto-tangle: t
#+auto-reload: ~/.emacs.d/init.el

* TODO Future

+ more tempel template (also move to its own section)
+ sql, nosql, redis client
+ consider using mwim
+ consider using literate-calc-mode
+ consider using smart-hungry-delete
+ consider using expand-region
+ consider using multi-compile
+ consider using prodigy and cask
+ consider using go-playground
+ consider using kubernetes-el
+ add folding
+ add debugger, dap-mode?
+ ai?

* Emacs Nix module

I'm still new to emacs, try reading this in the future:

- https://taingram.org/blog/intro-to-emacs-tempo.html

Noweb reference:
- epkgs :: emacs packages
- pkgs :: nix packages
- config :: nix configuration

#+begin_src nix :noweb yes
  {
    config,
    lib,
    pkgs,
    ...
  }:

  with lib;

  let
    minimalEmacs = pkgs.emacs.overrideAttrs (oldAttrs: {
      preBuild = (oldAttrs.preBuild or "") + ''
        rm -rf lisp/play
        rm -rf lisp/obsolete
        rm -f lisp/isearchb.el
      '';
    });

    emacs = minimalEmacs.pkgs.withPackages (epkgs: [
      <<epkgs>>
      ]);

    cfg = config.mod.emacs;
  in

    {
      options.mod.emacs = {
        enable = mkEnableOption "emacs";
      };

      config = mkIf cfg.enable {
        environment.systemPackages = [
          emacs
        <<pkgs>>
        ];

      <<config>>

      mod.activationScripts.tangleEmacsConfig.text = ''
        ${emacs}/bin/emacs ${./.}/emacs.org \
          -Q --batch --eval '(org-babel-tangle nil nil "^elisp$")' --kill
      '';
      };
    }
#+end_src

* Startup performance
:properties:
:header-args:elisp: :mkdirp yes :result silent :tangle ~/.emacs.d/early-init.el
:end:

Startup performance matters, I've seen a friend of mine opening Emacs and fully
load after 40 seconds. So keep the startup time low.

This will give us base information when startup wether our configuration is
optimized or not.

#+begin_src elisp
  (add-hook 'emacs-startup-hook
            (lambda ()
              (message "Emacs loaded in %s with %d garbage collections."
                       (format "%.2f seconds" (float-time (time-subtract after-init-time before-init-time)))
                       gcs-done)))
#+end_src

Temporary increase gc threshold during startup.

#+begin_src elisp
  (setq gc-cons-threshold most-positive-fixnum
        gc-cons-percentage 0.5)

  (add-hook 'emacs-startup-hook
            (lambda ()
              (setq gc-cons-threshold (* 8 100 100)
                    gc-cons-percentage 0.1)))
#+end_src

Maximize the frame.

#+begin_src elisp
  (add-to-list 'initial-frame-alist '(fullscreen . maximized))
  (add-to-list 'default-frame-alist '(fullscreen . maximized))
#+end_src

Removing some UI elements. Most of them are ugly. Prefer minimal look.

#+begin_src elisp
  (unless (memq window-system '(mac ns))
    (menu-bar-mode -1))
  (tool-bar-mode -1)
  (scroll-bar-mode -1)
  (horizontal-scroll-bar-mode -1)
  (tooltip-mode -1)
  (setq tab-bar-show nil)
#+end_src

Less noise, more peace.

#+begin_src elisp
  (setopt inhibit-startup-screen t
          inhibit-startup-buffer-menu t
          initial-scratch-message nil
          ring-bell-function 'ignore
          use-short-answers t)
#+end_src

Lastly, try to use lazy load =use-package=.

* Better default

Emacs are featureful out of the box, but has a bad default configuration. This
is an attempt to make a smooth default without 3rd party packages.

Smooth zooming with =0 - += and its shift counter part key.

#+begin_src elisp
  (define-key global-map (kbd "C-0") (lambda () (interactive) (text-scale-set 0)))
  (define-key global-map (kbd "C-)") (lambda () (interactive) (text-scale-set 0)))
  (define-key global-map (kbd "C--") 'text-scale-decrease)
  (define-key global-map (kbd "C-_") 'text-scale-decrease)
  (define-key global-map (kbd "C-=") 'text-scale-increase)
  (define-key global-map (kbd "C-+") 'text-scale-increase)
#+end_src

EditorConfig cover some file formatting in an editor-agnostic way.

#+begin_src elisp
  (editorconfig-mode t)
#+end_src

Make the buffer and its corresponding file in sync.

#+begin_src elisp
  (global-auto-revert-mode t)
#+end_src

Replace active region when insert text.

#+begin_src elisp
  (delete-selection-mode t)
#+end_src

Make TAB do indent + complete.

#+begin_src elisp
  (setq-default tab-always-indent 'complete)
#+end_src

Set tab to 4. We will define a global variable ~global-tab-width~ since other
major mode might have their own setting for this, we can override them with this
variable.

#+begin_src elisp
  (defvar global-tab-width 4)
  (setq-default tab-width global-tab-width)
#+end_src

Limit the column to 80 character.

#+begin_src elisp
  (setq-default fill-column 80)
  (add-hook 'text-mode-hook 'auto-fill-mode)
#+end_src

Treat subword movement for camel case in programming mode.

#+begin_src elisp
  (add-hook 'prog-mode-hook 'subword-mode)
#+end_src

Make script with shebang in it executable.

#+begin_src elisp
  (add-hook 'after-save-hook 'executable-make-buffer-file-executable-if-script-p)
#+end_src

Disable backup and lockfiles.

#+begin_src elisp
  (setopt make-backup-files nil
          create-lockfiles nil)
#+end_src

Better main buffer default.

#+begin_src elisp
  (setopt sentence-end-double-space nil)
#+end_src

* Environment and Nix

Makes Emacs aware of the environment, especially within [[https://nixos.org/][Nix]] ecosystems. This is
something you want to be setup early on.

** exec-path-from-shell

Read the system path from shell.

#+begin_src nix :tangle no :noweb-ref epkgs
  epkgs.exec-path-from-shell
#+end_src

#+begin_src elisp
  (use-package exec-path-from-shell
    :config
    (when (or (memq window-system '(mac ns x)) (daemonp))
      (dolist (var '("PATH"
                     "NIX_PATH"
                     "NIX_PROFILES"
                     "NIX_SSL_CERT_FILE"
                     "NIX_USER_PROFILE_DIR"
                     "__ETC_PROFILE_NIX_SOURCED"
                     "__NIX_DARWIN_SET_ENVIRONMENT_DONE"
                     "DIRENV_CONFIG"))
        (add-to-list 'exec-path-from-shell-variables var))
      (exec-path-from-shell-initialize)))
#+end_src

** envrc

#+begin_src nix :tangle no :noweb-ref config
  programs.direnv = {
    enable = true;
    nix-direnv.enable = true;
  };
#+end_src

#+begin_src nix :tangle no :noweb-ref epkgs
  epkgs.envrc
#+end_src

#+begin_src elisp
  (use-package envrc
    :hook
    (after-init . envrc-global-mode)
    :custom
    (envrc-debug t))
#+end_src

* UI

Who doesn't want a better UI?

** nerd-icons :font:

Nerd Fonts all the way.

#+begin_src nix :tangle no :noweb-ref config
  fonts.packages = [ pkgs.nerd-fonts.iosevka ];
#+end_src

#+begin_src nix :tangle no :noweb-ref epkgs
  epkgs.nerd-icons
#+end_src

#+begin_src elisp
  (use-package nerd-icons
    :custom
    (nerd-icons-font-family "Iosevka Nerd Font"))
#+end_src

** doom-themes :theme:

Not a fan of dark themes, but light themes also too bright. Solarized with warm
and low contrast is a sweet spot for me.

#+begin_src nix :tangle no :noweb-ref epkgs
  epkgs.doom-themes
#+end_src

#+begin_src elisp
  (use-package doom-themes
    :config
    (load-theme 'doom-solarized-light t)
    (doom-themes-org-config))
#+end_src

** doom-modeline :theme:

Doom modeline to complement the themes.

#+begin_src nix :tangle no :noweb-ref epkgs
  epkgs.doom-modeline
#+end_src

#+begin_src elisp
  (use-package doom-modeline
    :hook
    (after-init . doom-modeline-mode)
    :custom
    (doom-modeline-workspace-name nil))
#+end_src

** corfu :completion:

#+begin_src nix :tangle no :noweb-ref epkgs
  epkgs.corfu
#+end_src

#+begin_src elisp
  (use-package corfu
    :hook
    (after-init . global-corfu-mode)
    (after-init . corfu-popupinfo-mode)
    :bind
    (:map corfu-map
          ("C-j" . corfu-next)
          ("C-k" . corfu-previous))
    :custom
    (corfu-cycle t)
    (corfu-auto t)
    (corfu-auto-delay 0.0)
    (corfu-auto-prefix 2)
    (corfu-popupinfo-delay 0.0)
    (corfu-popupinfo-hide nil)
    :config
    (keymap-unset corfu-map "RET"))
#+end_src

** vertico :completion:

#+begin_src nix :tangle no :noweb-ref epkgs
  epkgs.vertico
#+end_src

#+begin_src elisp
  (use-package vertico
    :hook
    (after-init . vertico-mode)
    :bind
    (:map vertico-map
          ("C-j" . vertico-next)
          ("C-k" . vertico-previous)
          ("RET" . vertico-directory-enter)
          ("DEL" . vertico-directory-delete-char)
          ("M-DEL" . vertico-directory-delete-word))
    :custom
    (vertico-cycle t))
#+end_src

** TODO vertico-posframe :completion:

TODO: Evaluate whether I need this or not.

#+begin_src nix :tangle no :noweb-ref epkgs
  epkgs.vertico-posframe
#+end_src

#+begin_src elisp
  (use-package vertico-posframe
    :hook
    (after-init . vertico-posframe-mode)
    :custom
    (vertico-posframe-parameters
     '((left-fringe . 8)
       (right-fringe . 8))))
#+end_src

** marginalia :completion:

Add annotation to the minibuffer.

#+begin_src nix :tangle no :noweb-ref epkgs
  epkgs.marginalia
#+end_src

#+begin_src elisp
  (use-package marginalia
    :hook
    (after-init . marginalia-mode))
#+end_src

** nerd-icons-completion :completion:font:

Fix =nerd-icons= doesn't affect minibuffer.

#+begin_src nix :tangle no :noweb-ref epkgs
  epkgs.nerd-icons-completion
#+end_src

#+begin_src elisp
  (use-package nerd-icons-completion
    :after marginalia
    :hook
    (after-init . nerd-icons-completion-mode)
    (marginalia-mode . nerd-icons-completion-marginalia-setup))
#+end_src

** TODO focus :focus:

Focus around the point.

#+begin_src nix :tangle no :noweb-ref epkgs
  epkgs.focus
#+end_src

#+begin_src elisp
  (use-package focus)
#+end_src

** TODO golden-ratio :focus:

Focus on the current window.

#+begin_src nix :tangle no :noweb-ref epkgs
  epkgs.golden-ratio
#+end_src

#+begin_src elisp
  (use-package golden-ratio
    :hook
    (after-init . golden-ratio-mode)
    :config
    (advice-add 'windmove-left :after (lambda (&rest _) (golden-ratio)))
    (advice-add 'windmove-down :after (lambda (&rest _) (golden-ratio)))
    (advice-add 'windmove-up :after (lambda (&rest _) (golden-ratio)))
    (advice-add 'windmove-right :after (lambda (&rest _) (golden-ratio)))
    (advice-add 'avy-goto-char-2 :after (lambda (&rest _) (golden-ratio)))
    (advice-add 'smooth/jump-backward :after (lambda (&rest _) (golden-ratio))))
#+end_src

** spacious-padding

Give Emacs some space to breath.

#+begin_src nix :tangle no :noweb-ref epkgs
  epkgs.spacious-padding
#+end_src

#+begin_src elisp
  (use-package spacious-padding
    :hook
    (after-init . spacious-padding-mode)
    :custom
    (spacious-padding-widths
     '( :internal-border-width 15
        :header-line-width 4
        :mode-line-width 6
        :tab-width 4
        :right-divider-width 30
        :scroll-bar-width 8
        :fringe-width 4)))
#+end_src

** ansi-color

#+begin_src elisp
  (use-package ansi-color
    :hook
    (compilation-filter . ansi-color-compilation-filter))
#+end_src

** TODO pulsar

Visual indicator to help easily spot current line.

#+begin_src nix :tangle no :noweb-ref epkgs
  epkgs.pulsar
#+end_src

#+begin_src elisp
  (use-package pulsar
    :config
    ;; TODO: add keyword :pulse to ryo-modal for activating the pulse in that command.
    (advice-add 'smooth/jump-backward :after (lambda (&rest _) (pulsar-pulse-line-red))))
#+end_src

* TODO Smooth modal

Coming from Vim, modal editing is a must. In Emacs, we have options like [[https://github.com/emacs-evil/evil][evil]],
[[https://github.com/jyp/boon][boon]], and [[https://github.com/meow-edit/meow][meow]]. But I really like [[https://github.com/Kungsgeten/ryo-modal][ryo-modal]] where I can customize modal editing
to my own liking.

** ryo-modal

#+begin_src nix :tangle no :noweb-ref epkgs
  epkgs.ryo-modal
#+end_src

#+begin_src elisp :noweb yes
  (use-package ryo-modal
    :bind
    ("<escape>" . smooth-escape)
    :hook
    (after-init . global-ryo-modal-mode)
    :custom
    (cursor-type 'bar)
    (ryo-modal-cursor-type 'box)
    :config
    <<smooth-old-config>>
    <<smooth-config>>

    (ryo-modal-keys
     ("1" "M-1" :norepeat t)
     ("2" "M-2" :norepeat t)
     ("3" "M-3" :norepeat t)
     ("4" "M-4" :norepeat t)
     ("5" "M-5" :norepeat t)
     ("6" "M-6" :norepeat t)
     ("7" "M-7" :norepeat t)
     ("8" "M-8" :norepeat t)
     ("9" "M-9" :norepeat t)
     ("0" "M-0" :norepeat t)
     ("-" "M--" :norepeat t))

    (ryo-modal-keys
     <<smooth-motion>>
     <<smooth-insert>>
     <<smooth-editing>>
     <<smooth-goto>>
     )

    (ryo-modal-keys
     ("b" undefined)
     ("B" undefined)
     ("E" undefined)
     ("f" undefined)
     ("F" undefined)
     ("G" undefined)
     ("m" undefined)
     ("M" undefined)
     ("n" undefined)
     ("N" undefined)
     ("P" undefined)
     ("q" quit-window)
     ("Q" undefined)
     ("R" undefined)
     ("s" undefined)
     ("S" undefined)
     ("t" undefined)
     ("T" undefined)
     ("W" undefined)
     ("x" execute-extended-command)
     ("X" undefined)
     ("Y" undefined)
     ("z" undefined)
     ("Z" undefined))

    (ryo-modal-keys
     ("(" undefined)
     (")" undefined)
     ("{" undefined)
     ("}" undefined)
     ("[" undefined)
     ("]" undefined)
     ("<" undefined)
     (">" undefined)
     ("'" undefined)
     ("\"" undefined))

    (ryo-modal-keys
     ("<escape>" smooth-keyboard-quit)
     ("`" undefined)
     ("~" undefined)
     ("!" undefined)
     ("@" undefined)
     ("#" undefined)
     ("$" undefined)
     ("^" undefined)
     ("&" undefined)
     ("*" undefined)
     ("_" undefined)
     ("=" undefined)
     ("+" undefined)
     ("\\" undefined)
     ("|" undefined)
     ;; (";" :name "avy")
     (":" undefined)
     ("." undefined)
     ("/" undefined)
     ("?" undefined)))
#+end_src

** smooth-config

#+begin_src elisp :tangle no :noweb-ref smooth-config
  (defvar smooth--anchor-p nil)

  (defun smooth-activate-mark ()
    (push-mark (point) t t))

  (defun smooth-activate-mark-if-no-anchor ()
    (unless smooth--anchor-p
  	(smooth-activate-mark)))

  (defun smooth-deactivate-mark ()
    (deactivate-mark))

  (defun smooth-deactivate-mark-if-no-anchor ()
    (unless smooth--anchor-p
  	(smooth-deactivate-mark)))

  (defun smooth-activate-anchor ()
    (interactive)
    (setq smooth--anchor-p t)
    (message "Anchor set")
    (unless (use-region-p)
  	(smooth-activate-mark)))

  (defun smooth-activate-anchor-line ()
    (interactive)
    (setq smooth--anchor-p t)
    (message "Anchor set")
    (save-excursion
  	(when (use-region-p)
  	  (goto-char (mark)))
  	(beginning-of-line)
  	(smooth-activate-mark))
    (forward-line))

  (defun smooth-deactivate-anchor ()
    (interactive)
    (setq smooth--anchor-p nil)
    (smooth-deactivate-mark))

  (defun smooth-pulse-red ()
    (when (fboundp 'pulsar-pulse-line-red)
  	(pulsar-pulse-line-red)))

  (defun smooth-pulse-green ()
    (when (fboundp 'pulsar-pulse-line-green)
  	(pulsar-pulse-line-green)))

  (defun smooth-pulse-yellow ()
    (when (fboundp 'pulsar-pulse-line-yellow)
  	(pulsar-pulse-line-yellow)))

  (defun smooth-normal-mode ()
    (interactive)
    (smooth-pulse-green)
    (ryo-modal-mode 1))

  (defun smooth-insert-mode ()
    (interactive)
    (smooth-pulse-yellow)
    (smooth-deactivate-anchor)
    (ryo-modal-mode 0))

  (defun smooth-keyboard-quit ()
    (interactive)
    (smooth-pulse-red)
    (smooth-deactivate-anchor)
    (keyboard-quit))

  (defun smooth-kill (count)
    (interactive "p")
    (if (use-region-p)
  	  (kill-region (region-beginning) (region-end))
  	(delete-char count t)))

  (defun smooth-yank (count)
    (interactive "p")
    (if (use-region-p)
  	  (kill-ring-save (region-beginning) (region-end))
  	(kill-new (char-to-string (char-after)))))

  (defun smooth-put (count)
    (interactive "p")
    (when (use-region-p)
  	(delete-region (region-beginning) (region-end)))
    (yank))

  (defun smooth-open-line-below ()
    (interactive)
    (end-of-line)
    (newline)
    (indent-according-to-mode))

  (defun smooth-open-line-above ()
    (interactive)
    (beginning-of-line)
    (open-line 1)
    (indent-according-to-mode))

  (defun smooth-escape ()
    (interactive)
    (cond
     ;; 1. Corfu popup is visible
     ((and (bound-and-true-p corfu-mode)
        	 corfu--candidates)
      (corfu-quit)
      (ryo-modal-mode))

     ;; 2. Minibuffer
     ((when (minibufferp)
        (minibuffer-keyboard-quit)))

     ;; 3. Enter ryo-modal-mode
     (t (smooth-normal-mode))))
#+end_src

#+begin_src elisp :tangle no :noweb-ref smooth-old-config
  (defvar smooth/modal-blacklist
    '((predicate . minibufferp)
      (mode . eshell-mode)
      (mode . term-mode)
      (mode . vterm-mode)
      (mode . vc-git-log-edit-mode))
    "Alist of conditions where `ryo-modal-mode` should not be enabled.")

  (defun smooth/modal-blacklisted-p ()
    "Return non-nil if current buffer should not enable `ryo-modal-mode`."
    (cl-some
     (lambda (entry)
  	 (pcase entry
         (`(predicate . ,fn) (funcall fn))
         (`(mode . ,mode) (eq major-mode mode))))
     smooth/modal-blacklist))

  (define-globalized-minor-mode global-ryo-modal-mode
    ryo-modal-mode
    (lambda ()
      (unless (smooth/modal-blacklisted-p)
        (ryo-modal-mode 1))))

  (defvar smooth/pop-ring (make-ring 100)
    "A ring of pop commands recorded from various jump systems.")

  (defun smooth/record-pop (pop-fn)
    "Store POP-FN into `smooth/pop-ring` for later use."
    (ring-insert smooth/pop-ring pop-fn))

  (defun smooth/jump-backward ()
    "Execute the most recent pop command from `smooth/pop-ring`."
    (interactive)
    (unless (ring-empty-p smooth/pop-ring)
      (let ((fn (ring-remove smooth/pop-ring 0)))
        (call-interactively fn))))

  (advice-add 'xref-push-marker-stack
              :after (lambda (&rest _) (smooth/record-pop #'xref-pop-marker-stack)))

  (advice-add 'avy-push-mark
              :after (lambda (&rest _) (smooth/record-pop #'avy-pop-mark)))

  ;; TODO: any push-mark from xref and avy also trigger general push-mark
  ;; This is problematic as pushing the command in the ring will be doubled.
  ;; (advice-add 'push-mark
  ;;                    :after (lambda (&rest _) (smooth/record-pop #'pop-to-mark-command)))
#+end_src

** smooth-motion

#+begin_src elisp :tangle no :noweb-ref smooth-motion
  ("%" mark-whole-buffer :first '(smooth-deactivate-anchor))
  ("v" smooth-activate-anchor)
  ("V" smooth-activate-anchor-line)
  ("," pop-to-mark-command :then '(smooth-deactivate-anchor))

  ("h" backward-char :first '(smooth-deactivate-mark-if-no-anchor))
  ("j" next-line :first '(smooth-deactivate-mark-if-no-anchor))
  ("k" previous-line :first '(smooth-deactivate-mark-if-no-anchor))
  ("l" forward-char :first '(smooth-deactivate-mark-if-no-anchor))

  ("H" backward-word :first '(smooth-activate-mark-if-no-anchor))
  ("J" forward-paragraph :first '(smooth-activate-mark-if-no-anchor))
  ("K" backward-paragraph :first '(smooth-activate-mark-if-no-anchor))
  ("L" forward-word :first '(smooth-activate-mark-if-no-anchor))

  ("g h" move-beginning-of-line :first '(smooth-activate-mark-if-no-anchor))
  ("g j" end-of-buffer :first '(smooth-activate-mark-if-no-anchor))
  ("g k" beginning-of-buffer :first '(smooth-activate-mark-if-no-anchor))
  ("g l" move-end-of-line :first '(smooth-activate-mark-if-no-anchor))
#+end_src

** smooth-insert

#+begin_src elisp :tangle no :noweb-ref smooth-insert
  ("i" smooth-insert-mode)
  ("a" smooth-insert-mode :first '(forward-char))
  ("o" smooth-insert-mode :first '(smooth-open-line-below))
  ("c" smooth-insert-mode :first '(smooth-kill))

  ("I" smooth-insert-mode :first '(move-beginning-of-line))
  ("A" smooth-insert-mode :first '(move-end-of-line))
  ("O" smooth-insert-mode :first '(smooth-open-line-above))
  ("C" smooth-insert-mode :first '(kill-line))
#+end_src

** smooth-editing

#+begin_src elisp :tangle no :noweb-ref smooth-editing
  ("y" smooth-yank :then '(smooth-deactivate-mark))
  ("p" smooth-put :then '(smooth-deactivate-mark))
  ("u" undo-only :then '(smooth-deactivate-anchor))
  ("U" undo-redo :then '(smooth-deactivate-anchor))
  ("d" smooth-kill :then '(smooth-deactivate-anchor))
  ("D" kill-line :then '(smooth-deactivate-anchor))
#+end_src

#+begin_src elisp :tangle no :noweb-ref eglot
  ("r" eglot-rename :first '(smooth-deactivate-anchor))
#+end_src

** smooth-goto

#+begin_src elisp :tangle no :noweb-ref smooth-goto
  ("w h" windmove-left :then '(smooth-pulse-green))
  ("w j" windmove-down :then '(smooth-pulse-green))
  ("w k" windmove-up :then '(smooth-pulse-green))
  ("w l" windmove-right :then '(smooth-pulse-green))
#+end_src

#+begin_src elisp :tangle no :noweb-ref eglot
  ("g i" eglot-find-implementation :first '(smooth-deactivate-anchor))
#+end_src

#+begin_src elisp :tangle no :noweb-ref xref
  ("g d" xref-find-definitions :first '(smooth-deactivate-anchor))
  ("g r" xref-find-references :first '(smooth-deactivate-anchor))
#+end_src

#+begin_src elisp :tangle no :noweb-ref consult
  ("g m" consult-imenu :first '(smooth-deactivate-anchor))
  ("g e" consult-flymake :first '(smooth-deactivate-anchor))
#+end_src

#+begin_src elisp :tangle no :noweb-ref flymake
  ("e j" flymake-goto-next-error :name "goto next error")
  ("e k" flymake-goto-prev-error :name "goto prev error")
#+end_src

** smooth-project

#+begin_src elisp :tangle no :noweb-ref project
  ("SPC p" project-switch-project :name "project")
  ("SPC SPC d" project-dired :name "root directory")
  ("SPC d" dired-jump :name "directory")
  ("SPC SPC f" project-find-file :name "root file")
  ("SPC f" find-file :name "file")
  ("SPC c" project-compile  :name "compile")
  ("SPC e" project-eshell :name "eshell")
  ("SPC b" project-switch-to-buffer :name "buffer")
#+end_src

#+begin_src elisp :tangle no :noweb-ref harpoon
  ("SPC a" harpoon-add-file)
  ("SPC o" harpoon-toggle-file)

  ("SPC 1" harpoon-go-to-1)
  ("SPC 2" harpoon-go-to-2)
  ("SPC 3" harpoon-go-to-3)
  ("SPC 4" harpoon-go-to-4)
  ("SPC 4" harpoon-go-to-5)
#+end_src

** smooth-help

#+begin_src elisp :tangle no :noweb-ref helpful
  ("SPC h"
   (("h" helpful-at-point :name "describe at point")
    ("m" describe-mode :name "describe mode")
    ("v" helpful-variable :name "describe variable")
    ("f" helpful-callable :name "describe function")
    ("k" helpful-key :name "describe key")
    ("x" helpful-command :name "describe command")
    ("j" pp-macroexpand-last-sexp))
   :name "help")
#+end_src

** smooth-avy

[[https://karthinks.com/software/avy-can-do-anything/][Avy can do anything]]. However, most of the time, I only use =avy= for jump only.

#+begin_src nix :tangle no :noweb-ref epkgs
  epkgs.avy
#+end_src

#+begin_src elisp :noweb yes
  (use-package avy
    :ryo
    (";" avy-goto-char-2 :then '(smooth-pulse-green))
    :custom
    (avy-single-candidate-jump nil)
    (avy-style 'words)
    (avy-dispatch-alist nil))
#+end_src

* Help system

** helpful

#+begin_src nix :tangle no :noweb-ref epkgs
  epkgs.helpful
#+end_src

#+begin_src elisp :noweb yes
  (use-package helpful
    :ryo
    <<helpful>>
    )
#+end_src

** which-key

#+begin_src nix :tangle no :noweb-ref epkgs
  epkgs.which-key
#+end_src

#+begin_src elisp
  (use-package which-key
    :hook
    (after-init . which-key-mode))
#+end_src

** keycast

#+begin_src nix :tangle no :noweb-ref epkgs
  epkgs.keycast
#+end_src

** markdown-mode

#+begin_src nix :tangle no :noweb-ref epkgs
  epkgs.markdown-mode
#+end_src

#+begin_src elisp
  (use-package markdown-mode
    :mode
    (rx ".md" eos))
#+end_src

* Project

** project

#+begin_src elisp :noweb yes
  (use-package project
    :ryo
    <<project>>
    :custom
    (project-switch-commands #'smooth/project-auto-buffer)
    :config
    (defun smooth/project-auto-buffer ()
      "After switching to a project, jump to its first buffer or *scratch*."
      (interactive)
      (let* ((pr (project-current))
             (buffers (project-buffers pr)))
        (if buffers
            (switch-to-buffer (car buffers))
          (project-find-file)))))
#+end_src

** otpp

#+begin_src nix :tangle no :noweb-ref epkgs
  epkgs.otpp
#+end_src

#+begin_src elisp :noweb yes
  (use-package otpp
    :ryo
    ("SPC j"
     (("e" smooth/open-emacs-config :name "open emacs config")
  	("w" smooth/open-work-readme :name "open work README"))
     :name "jump to special file")
    :hook
    (after-init . otpp-mode)
    (after-init . otpp-override-mode)
    :config
    (setq frame-title-format
          '(:eval
            (alist-get 'name (tab-bar--current-tab))))

    (defun smooth/open-emacs-config ()
      (interactive)
      (let ((buf (find-file "~/.config/smoothconf/modules/emacs.org")))
        (otpp-detach-buffer-to-tab buf)))

    (defun smooth/open-work-readme ()
      (interactive)
      (find-file "~/work/README.org")))
#+end_src

** harpoon

#+begin_src nix :tangle no :noweb-ref epkgs
  epkgs.harpoon
#+end_src

#+begin_src elisp :noweb yes
  (use-package harpoon
    :defer t
    :ryo
    <<harpoon>>
    )
#+end_src

* Completion

Completion are essential feature for modern text editor / IDE.

#+begin_src elisp
  (setq read-file-name-completion-ignore-case t
        read-buffer-completion-ignore-case t
        completion-ignore-case t)
#+end_src

** consult

#+begin_src nix :tangle no :noweb-ref epkgs
  epkgs.consult
#+end_src

#+begin_src elisp :noweb yes
  (use-package consult
    :ryo
    <<consult>>
    :custom
    (xref-show-xrefs-function #'consult-xref)
    (xref-show-definitions-function #'consult-xref))
#+end_src

** orderless

#+begin_src nix :tangle no :noweb-ref epkgs
  epkgs.orderless
#+end_src

#+begin_src elisp
  (use-package orderless
    :custom
    (completion-styles '(orderless basic))
    (completion-category-default nil)
    (completion-category-overrides '((file (styles partial-completion))))
    (orderless-matching-styles '(orderless-flex)))
#+end_src

** cape

#+begin_src nix :tangle no :noweb-ref epkgs
  epkgs.cape
#+end_src

#+begin_src elisp
  (use-package cape
    :config
    (add-hook 'completion-at-point-functions #'cape-file)
    (add-hook 'completion-at-point-functions #'cape-elisp-block))
#+end_src

** tempel

#+begin_src nix :tangle no :noweb-ref epkgs
  epkgs.tempel
  epkgs.eglot-tempel
#+end_src

#+begin_src elisp
  (use-package tempel)

  (use-package eglot-tempel
    :hook
    (after-init . eglot-tempel-mode))
#+end_src

* LSP

#+begin_src elisp :tangle no :noweb-ref eldoc-box
  ("d" eldoc-box-help-at-point :name "document")
#+end_src

** eglot

We will use built-in =eglot= for LSP. Make sure the LSP server is installed in the
system path and configure the following variable:

+ eglot-server-programs :: mapping between major mode and the LSP server
+ eglot-workspace-configuration :: configuration for the LSP server

#+begin_src elisp :noweb yes
  (use-package eglot
    :ryo
    <<eglot>>
    :hook
    (prog-mode . eglot-ensure)
    (prog-mode . (lambda () (add-hook 'before-save-hook 'eglot-format-buffer)))
    :custom
    (eglot-events-buffer-config '(:size 0))
    :config
    (setq eglot-server-programs '(
                                  <<eglot-server-programs>>
                                  ))
    (setq-default eglot-workspace-configuration
                  '(
                    <<eglot-workspace-configuration>>
                    )))
#+end_src

** eglot-booster

Boost LSP performance with =eglot-booster=.

#+begin_src nix :tangle no :noweb-ref pkgs
  pkgs.emacs-lsp-booster
#+end_src

#+begin_src nix :tangle no :noweb-ref epkgs
  epkgs.eglot-booster
#+end_src

#+begin_src elisp
  (use-package eglot-booster :after eglot :config (eglot-booster-mode))
#+end_src

** eldoc

#+begin_src elisp
  (use-package eldoc
    :custom
    (eldoc-idle-delay 0.0)
    (eldoc-echo-area-use-multiline-p 1)
    (eldoc-echo-area-display-truncation-message nil))
#+end_src

** eldoc-box

#+begin_src nix :tangle no :noweb-ref epkgs
  epkgs.eldoc-box
#+end_src

#+begin_src elisp :noweb yes
  (use-package eldoc-box
    :ryo
    ;; <<eldoc-box>>
    )
#+end_src

** flymake

#+begin_src elisp :noweb yes
  (use-package flymake
    :ryo
    <<flymake>>
    )
#+end_src

** xref

#+begin_src elisp :noweb yes
  (use-package xref
    :ryo
    <<xref>>
    )
#+end_src

* Programming language

Syntax highlighting require [[https://tree-sitter.github.io/tree-sitter/][Tree-sitter]] grammars, this will install all
available grammars.

#+begin_src nix :tangle no :noweb-ref epkgs
  epkgs.treesit-grammars.with-all-grammars
#+end_src

** go :main:

#+begin_src nix :tangle no :noweb-ref pkgs
  pkgs.go
    pkgs.gopls
    pkgs.delve
#+end_src

#+begin_src nix :tangle no :noweb-ref epkgs
  # go-ts-mode is already emacs built-in major mode
#+end_src

#+begin_src elisp
  (use-package go-ts-mode
    :mode
    (rx ".go" eos)
    :custom
    (go-ts-mode-indent-offset global-tab-width))
#+end_src

#+begin_src elisp :tangle no :noweb-ref eglot-server-programs
  ((go-mode go-dot-mod-mode go-dot-work-mode go-ts-mode go-mod-ts-mode) . ("gopls"))
#+end_src

#+begin_src elisp :tangle no :noweb-ref eglot-workspace-configuration
  (:gopls . (:gofumpt t))
#+end_src

** gleam :main:

#+begin_src nix :tangle no :noweb-ref pkgs
  pkgs.gleam
#+end_src

#+begin_src nix :tangle no :noweb-ref epkgs
  epkgs.gleam-ts-mode
#+end_src

#+begin_src elisp
  (use-package gleam-ts-mode
    :mode
    (rx ".gleam" eos))
#+end_src

#+begin_src elisp :tangle no :noweb-ref eglot-server-programs
  (gleam-ts-mode . ("gleam" "lsp"))
#+end_src

** erlang

#+begin_src nix :tangle no :noweb-ref pkgs
  pkgs.beam28Packages.erlang
  pkgs.erlang-language-platform
#+end_src

#+begin_src elisp :tangle no :noweb-ref epkgs
  epkgs.erlang-ts
#+end_src

#+begin_src elisp
  (use-package erlang-ts-mode
    :mode
    (rx ".erl" eos))
#+end_src

#+begin_src elisp :tangle no :noweb-ref eglot-server-programs
  (erlang-ts-mode . ("elp" "server"))
#+end_src

** elisp :conf:

Emacs at the heart is a Lisp interpreter, so everything already available out of
the box.

** nix :conf:

#+begin_src nix :tangle no :noweb-ref pkgs
  pkgs.nil
  pkgs.nixfmt
#+end_src

#+begin_src nix :tangle no :noweb-ref epkgs
  epkgs.nix-ts-mode
#+end_src

#+begin_src elisp
  (use-package nix-ts-mode
    :mode
    (rx ".nix" eos)
    :hook
    (nix-ts-mode . smooth/nix-ts-mode-noweb-comment)
    :config
    (defun smooth/nix-ts-mode-noweb-comment ()
      "Treat `<<...>>` as comment in nix-mode to avoid indentation errors."
      (font-lock-add-keywords
       nil '(("<<.*?>>" . font-lock-comment-face)))))
#+end_src

#+begin_src elisp :tangle no :noweb-ref eglot-server-programs
  (nix-ts-mode . ("nil"))
#+end_src

#+begin_src elisp :tangle no :noweb-ref eglot-workspace-configuration
  (:nil . (:formatting (:command ["nixfmt"])))
#+end_src

** js/json

#+begin_src elisp
  (use-package js
    :mode
    ((rx ".js" eos)
     (rx ".json" eos))
    :custom
    (js-indent-level 2))
#+end_src

** guile :noob:

#+begin_src nix :tangle no :noweb-ref pkgs
  pkgs.guile
#+end_src

#+begin_src nix :tangle no :noweb-ref epkgs
  epkgs.geiser
    epkgs.geiser-guile
#+end_src

#+begin_src elisp
  (use-package geiser
    :defer t)

  (use-package geiser-guile
    :defer t)
#+end_src

** lua :noob:

#+begin_src nix :tangle no :noweb-ref pkgs
  pkgs.luajit
  pkgs.lua-language-server
#+end_src

#+begin_src nix :tangle no :noweb-ref epkgs
  # lua-ts-mode is already emacs built-in major mode
#+end_src

#+begin_src elisp
  (use-package lua-ts-mode
    :mode
    (rx ".lua" eos))
#+end_src

#+begin_src elisp :tangle no :noweb-ref eglot-server-programs
  ((lua-ts-mode) . ("lua-language-server"))
#+end_src

* Org

#+begin_src elisp :tangle no :noweb-ref org
  ("SPC SPC c" org-ctrl-c-ctrl-c)
  ;; insert structure template
  ;; see: org-structure-template-alist
#+end_src

#+begin_src elisp :tangle no :noweb-ref org-insert
  ("SPC i"
   (("t" org-insert-structure-template :name "insert template")
    ("h" org-babel-insert-header-arg :name "insert header")
    ("l" org-insert-link :name "insert link"))
   :name "org insert")
#+end_src

#+begin_src elisp :tangle no :noweb-ref babel
  ("SPC SPC t" org-babel-tangle)
#+end_src

** org

#+begin_src elisp :noweb yes
  (use-package org
    :ryo
    (:mode 'org-mode)
    <<org>>
    <<org-insert>>
    <<babel>>
    :hook (after-save . org-auto--tangle-and-reload)
    :custom
    ;; Edit settings.
    (org-auto-align-tags nil)
    (org-tags-column 0)
    (org-catch-invisible-edits 'show-and-error)
    (org-special-ctrl-a/e t)
    (org-insert-heading-respect-content t)
    ;; Org styling, hide markup etc.
    (org-startup-indented t)
    (org-startup-folded 'content)
    (org-hide-emphasis-markers t)
    (org-pretty-entities t)
    (org-agenda-tags-column 0)
    (org-ellipsis "â€¦")
    (org-cycle-separator-lines 0)
    (org-imenu-depth 3)
    :config
    (defun org-auto--find-keywords-value (key)
  	(car (cdr (assoc (upcase key) (org-collect-keywords (list key))))))

    (defun org-auto--tangle-and-reload ()
      (when (derived-mode-p 'org-mode)
        (let ((auto-tangle (org-auto--find-keywords-value "auto-tangle"))
              (auto-reload (org-auto--find-keywords-value "auto-reload")))
          (when (string= auto-tangle "t")
            (org-babel-tangle))
          (when auto-reload
            (load-file auto-reload)
  		  (message "auto reload"))))))
#+end_src

** org-modern

The default look is old with no icon, make the look modern.

#+begin_src nix :tangle no :noweb-ref epkgs
  epkgs.org-modern
#+end_src

#+begin_src elisp
  (use-package org-modern
    :hook
    (org-mode . org-modern-mode))
#+end_src

** org-modern-indent

Package =org-modern-mode= is [[https://github.com/minad/org-modern?tab=readme-ov-file#incompatibilities][incompatible]] with built-in =org-indent-mode=, fix them
with =org-modern-indent-mode=.

#+begin_src nix :tangle no :noweb-ref epkgs
  (pkgs.emacsPackages.trivialBuild {
    pname = "org-modern-indent";
    version = "0.5.1";
    src = pkgs.fetchFromGitHub {
      owner = "jdtsmith";
      repo = "org-modern-indent";
      rev = "v0.5.1";
      sha256 = "sha256-st3338Jk9kZ5BLEPRJZhjqdncMpLoWNwp60ZwKEObyU=";
    };
  })
#+end_src

#+begin_src elisp
  (use-package org-modern-indent
    :hook (org-mode . org-modern-indent-mode))
#+end_src

** TODO ob-babel

Register the programming languages to support in evaluation. See [[https://orgmode.org/worg/org-contrib/babel/languages/index.html][Babel language
support]].

#+begin_src elisp
  (org-babel-do-load-languages
   'org-babel-load-languages
   '((emacs-lisp . t)
     (verb . t)))
  (setq org-confirm-babel-evaluate nil)
#+end_src

Register missing major mode for some programing languages.

+ C-h v org-src-lang-modes RET :: see registered major mode (some already registered by default)

#+begin_src elisp
  (add-to-list 'org-src-lang-modes '("nix" . nix-ts))
  (add-to-list 'org-src-lang-modes '("js" . js))
  (add-to-list 'org-src-lang-modes '("json" . js))
#+end_src

** TODO ox-hugo

#+begin_src nix :tangle no :noweb-ref epkgs
  epkgs.ox-hugo
#+end_src

#+begin_src elisp
  (use-package ox-hugo
    :after ox)
#+end_src

** TODO org-present

#+begin_src nix :tangle no :noweb-ref epkgs
  epkgs.org-present
#+end_src

** TODO org-roam

#+begin_src nix :tangle no :noweb-ref epkgs
  epkgs.org-roam
    epkgs.org-roam-ui
#+end_src

** verb

#+begin_src nix :tangle no :noweb-ref epkgs
  epkgs.verb
#+end_src

#+begin_src elisp
  (use-package verb
    :hook
    ((org-mode . smooth/org-enable-verb-mode-if-has-tag)
     (org-after-tags-change-hook . smooth/org-enable-verb-mode-if-has-tag))
    :config
    (defun smooth/org-enable-verb-mode-if-has-tag ()
      "Toggle `verb-mode` based on Org buffer has the tag :verb:."
      (interactive)
      (if (member '("verb") (org-get-buffer-tags))
          (verb-mode 1)
        (verb-mode -1))))
#+end_src

** hurl

#+begin_src nix :tangle no :noweb-ref pkgs
  pkgs.hurl
#+end_src

#+begin_src nix :tangle no :noweb-ref epkgs
  (pkgs.emacsPackages.trivialBuild {
    pname = "hurl-mode";
    version = "0.0.0";
    src = pkgs.fetchFromGitHub {
      owner = "JasZhe";
      repo = "hurl-mode";
      rev = "0753271bb4693924d3dcfa9d66a316086d7b7b72";
      sha256 = "sha256-56/XDXYG4pq3+liB9TDIISTlmN4xMGsic9jhrIacO5E=";
    };
  })
#+end_src

#+begin_src elisp
  (use-package hurl-mode
    :mode
    (rx ".hurl" eos))
#+end_src

* Version control :SPC:g:

#+begin_src elisp :tangle no :noweb-ref magit
  ("SPC g"
   (("s" magit-status :name "status"))
   :name "git")
  (:mode 'magit-mode)
  ("j" magit-section-forward)
  ("k" magit-section-backward)
  ("TAB" magit-section-toggle)
  ("q" magit-mode-bury-buffer)
  ("d" magit-diff-dwim)
  ("a" magit-apply)
  ("x" magit-discard)
  ("s" magit-stage)
  ("u" magit-unstage)
  ("c c" magit-commit-create)
  ("c a" magit-commit-amend)
  ("p u" magit-push-current-to-upstream)
#+end_src

#+begin_src elisp :tangle no :noweb-ref blamer
  ("SPC v b" blamer-show-posframe-commit-info :name "blame")
#+end_src

** magit

#+begin_src nix :tangle no :noweb-ref epkgs
  epkgs.magit
#+end_src

#+begin_src elisp :noweb yes
  (use-package magit
    :ryo
    <<magit>>
    :custom
    (auto-revert-check-vc-info t))
#+end_src

** diff-hl

#+begin_src nix :tangle no :noweb-ref epkgs
  epkgs.diff-hl
#+end_src

#+begin_src elisp
  (use-package diff-hl
    :hook
    (after-init . global-diff-hl-mode)
    (magit-post-refresh . diff-hl-magit-post-refresh)
    :custom
    (diff-hl-bmp-max-width 8))
#+end_src

** blamer

#+begin_src nix :tangle no :noweb-ref epkgs
  epkgs.blamer
#+end_src

#+begin_src elisp :noweb yes
  (use-package blamer
    :ryo
    <<blamer>>
    )
#+end_src

* TODO Accounting

** ledger-mode

#+begin_src nix :tangle no :noweb-ref pkgs
  pkgs.ledger
#+end_src

#+begin_src nix :tangle no :noweb-ref epkgs
  epkgs.ledger-mode
#+end_src

#+begin_src elisp
  (use-package ledger-mode)
#+end_src

* Misc

** jwt

#+begin_src nix :tangle no :noweb-ref epkgs
  epkgs.jwt
#+end_src

#+begin_src elisp
  (use-package jwt
    :defer t)
#+end_src
